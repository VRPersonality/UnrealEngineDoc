<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unreal Engine 5.6 C++ API: Runtime/Engine/Public/GPUSortManager.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Unreal Engine 5.6 C++ API<span id="projectnumber">&#160;5.6.0</span>
   </div>
   <div id="projectbrief">C++ API documentation for Unreal Engine 5.6</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('GPUSortManager_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">GPUSortManager.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="CoreMinimal_8h_source.html">CoreMinimal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RefCounting_8h_source.html">Templates/RefCounting.h</a>&quot;</code><br />
<code>#include &quot;RHI.h&quot;</code><br />
<code>#include &quot;<a class="el" href="RenderResource_8h_source.html">RenderResource.h</a>&quot;</code><br />
</div>
<p><a href="GPUSortManager_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:FGPUSortManager" id="r_FGPUSortManager"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFGPUSortManager.html">FGPUSortManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A manager that handles different GPU sort tasks.  <a href="classFGPUSortManager.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFAllocationInfo" id="r_FGPUSortManager_3A_3AFAllocationInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFGPUSortManager_1_1FAllocationInfo.html">FGPUSortManager::FAllocationInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about the bindings for a given sort task.  <a href="structFGPUSortManager_1_1FAllocationInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFCallbackInfo" id="r_FGPUSortManager_3A_3AFCallbackInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFGPUSortManager_1_1FCallbackInfo.html">FGPUSortManager::FCallbackInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds data relative to client systems of the GPU sort manager.  <a href="structFGPUSortManager_1_1FCallbackInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFDynamicValueBuffer" id="r_FGPUSortManager_3A_3AFDynamicValueBuffer"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFGPUSortManager_1_1FDynamicValueBuffer.html">FGPUSortManager::FDynamicValueBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encapsulates the idea of a growable <a class="el" href="classFGPUSortManager_1_1FValueBuffer.html" title="A vertex buffer owning the final sorted values.">FValueBuffer</a>, that dynamically change in size depending on requirements.  <a href="structFGPUSortManager_1_1FDynamicValueBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFKeyGenInfo" id="r_FGPUSortManager_3A_3AFKeyGenInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFGPUSortManager_1_1FKeyGenInfo.html">FGPUSortManager::FKeyGenInfo</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A little helper to generate the batch element keys based on the number of elements in the batch and the sort precision.  <a href="structFGPUSortManager_1_1FKeyGenInfo.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFSettings" id="r_FGPUSortManager_3A_3AFSettings"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFGPUSortManager_1_1FSettings.html">FGPUSortManager::FSettings</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different settings used to manage the buffer allocations.  <a href="structFGPUSortManager_1_1FSettings.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFSortBatch" id="r_FGPUSortManager_3A_3AFSortBatch"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFGPUSortManager_1_1FSortBatch.html">FGPUSortManager::FSortBatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines a sort batch that regroups several sort tasks created by <a class="el" href="classFGPUSortManager.html#a3e679326cae8e894414ee5eabedcb8e8" title="Add a GPU sort task to process this frame.">FGPUSortManager::AddTask()</a>, becoming sort the batch elements.  <a href="structFGPUSortManager_1_1FSortBatch.html#details">More...</a><br /></td></tr>
<tr class="memitem:FGPUSortManager_3A_3AFValueBuffer" id="r_FGPUSortManager_3A_3AFValueBuffer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFGPUSortManager_1_1FValueBuffer.html">FGPUSortManager::FValueBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vertex buffer owning the final sorted values.  <a href="classFGPUSortManager_1_1FValueBuffer.html#details">More...</a><br /></td></tr>
<tr class="memitem:FParticleSortBuffers" id="r_FParticleSortBuffers"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFParticleSortBuffers.html">FParticleSortBuffers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Buffers in GPU memory used to sort particles.  <a href="classFParticleSortBuffers.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9ff3a0d25b04773ce27866f66eea39b9" id="r_a9ff3a0d25b04773ce27866f66eea39b9"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9">EGPUSortFlags</a> : uint32 { <br />
&#160;&#160;<a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0x00
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a2adfd6e2c47c97daaade0690f919dbf3">LowPrecisionKeys</a> = 0x01
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a54737b6e1f1de6b175cac2ad38daf966">HighPrecisionKeys</a> = 0x02
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a6878d59f868118ac98b3fc2f3ba3a106">AnyKeyPrecision</a> = 0x03
, <br />
&#160;&#160;<a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a00c5859ce439ee8aa1047a737e857152">KeyGenAfterPreRender</a> = 0x04
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a5e001f1d59d743aa0ab94f080f01bd7b">KeyGenAfterPostRenderOpaque</a> = 0x08
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9ae5e866cc673d8accd816936ba3e76525">AnyKeyGenLocation</a> = 0x0C
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a5be97b223105b17aa32b4f3cb53c9f73">SortAfterPreRender</a> = 0x10
, <br />
&#160;&#160;<a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a36ace15a900e67ea470f504c487aa0da">SortAfterPostRenderOpaque</a> = 0x20
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9aa74778a62c6e7a091143dbba810a7fb6">AnySortLocation</a> = 0x30
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a39ce58881e43fc13193dd50be8d8360a">ValuesAsG16R16F</a> = 0x40
, <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9aa893550952d7007756585f9a6e715693">ValuesAsInt32</a> = 0x80
, <br />
&#160;&#160;<a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a23a36eeaad01b1f76979d14135f652ea">AnyValueFormat</a> = 0xC0
<br />
 }</td></tr>
<tr class="memdesc:a9ff3a0d25b04773ce27866f66eea39b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different sort flags used to define constraint for <a class="el" href="classFGPUSortManager.html" title="A manager that handles different GPU sort tasks.">FGPUSortManager</a> tasks.  <a href="#a9ff3a0d25b04773ce27866f66eea39b9">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a58ff6a6755410d24d26568cfaa590297" id="r_a58ff6a6755410d24d26568cfaa590297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58ff6a6755410d24d26568cfaa590297">CopyUIntBufferToTargets</a> (FRHICommandList &amp;RHICmdList, ERHIFeatureLevel::Type FeatureLevel, FRHIShaderResourceView *SourceSRV, FRHIUnorderedAccessView *const *TargetUAVs, <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> *TargetSizes, <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> StartingOffset, <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> NumTargets)</td></tr>
<tr class="memdesc:a58ff6a6755410d24d26568cfaa590297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy one uint buffer into several overlapping targets.  <br /></td></tr>
<tr class="memitem:aae86b6871b5c891dddfea43583674630" id="r_aae86b6871b5c891dddfea43583674630"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae86b6871b5c891dddfea43583674630">ENUM_CLASS_FLAGS</a> (<a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9">EGPUSortFlags</a>) <a class="el" href="DelegateCombinations_8h.html#abb99a9c6443c4c1d3c3329fa9a147804">DECLARE_DELEGATE_SixParams</a>(FGPUSortKeyGenDelegate</td></tr>
<tr class="memdesc:aae86b6871b5c891dddfea43583674630"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback used by the <a class="el" href="classFGPUSortManager.html" title="A manager that handles different GPU sort tasks.">FGPUSortManager</a> to make each client system initialize the sort keys for a specific sort batch.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4a3e37551b3938a562a688580e6eac00" id="r_a4a3e37551b3938a562a688580e6eac00"><td class="memItemLeft" align="right" valign="top">FRHICommandListImmediate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a3e37551b3938a562a688580e6eac00">EGPUSortFlags</a></td></tr>
<tr class="memitem:a5613c6c7c852953c5ac0195f5c5e83e9" id="r_a5613c6c7c852953c5ac0195f5c5e83e9"><td class="memItemLeft" align="right" valign="top">FRHICommandListImmediate&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5613c6c7c852953c5ac0195f5c5e83e9">int32</a></td></tr>
</table>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a9ff3a0d25b04773ce27866f66eea39b9" name="a9ff3a0d25b04773ce27866f66eea39b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ff3a0d25b04773ce27866f66eea39b9">&#9670;&#160;</a></span>EGPUSortFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9">EGPUSortFlags</a> : <a class="el" href="Platform_8h.html#a8c7a127091efbdfc5a16939041653e05">uint32</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Different sort flags used to define constraint for <a class="el" href="classFGPUSortManager.html" title="A manager that handles different GPU sort tasks.">FGPUSortManager</a> tasks. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a6adf97f83acf6453d4a6a4b1070f3754" name="a9ff3a0d25b04773ce27866f66eea39b9a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a2adfd6e2c47c97daaade0690f919dbf3" name="a9ff3a0d25b04773ce27866f66eea39b9a2adfd6e2c47c97daaade0690f919dbf3"></a>LowPrecisionKeys&#160;</td><td class="fielddoc"><p>Sorting happens on either 16 bit keys or 32 bit uint keys. </p>
<p>Those can come from float point formats being converted to uint. Because sort tasks are grouped into batches, the keys also have to start with the batch element index, which ends up either increasing the 16 bit keys or taking space in the 32 bit keys (by the number of bits required to store the element indices). The more task are created, the more bits are required to encode the element index (up to a limit of 16^2 elements). Low precision keys have the advantage of being quicker on the GPU when performing the radix sort, which is affected by the number of bits. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a54737b6e1f1de6b175cac2ad38daf966" name="a9ff3a0d25b04773ce27866f66eea39b9a54737b6e1f1de6b175cac2ad38daf966"></a>HighPrecisionKeys&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a6878d59f868118ac98b3fc2f3ba3a106" name="a9ff3a0d25b04773ce27866f66eea39b9a6878d59f868118ac98b3fc2f3ba3a106"></a>AnyKeyPrecision&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a00c5859ce439ee8aa1047a737e857152" name="a9ff3a0d25b04773ce27866f66eea39b9a00c5859ce439ee8aa1047a737e857152"></a>KeyGenAfterPreRender&#160;</td><td class="fielddoc"><p>The sort task are created in <a class="el" href="classFPrimitiveSceneProxy.html#a80d761e92a9c76e540e6801c6d551fd4" title="Gathers the primitive&#39;s dynamic mesh elements.">FPrimitiveSceneProxy::GetDynamicMeshElements()</a> but have different requirements in terms of when the keys can be generated, and when the sorted values are required within the frame. </p>
<p>Cascade renders the particles after GPU simulation (either in PreRender(), or in PostRenderOpaque() see ::CollisionDepthBuffer). Niagara, on the other hand, renders the particle before they get updated by simulation (either in PreInitViews() or PostRenderOpaque()) For Niagara emitters updated in PreInitViews(), this happens before GetDynamicMeshElements() so doesn't impose any restriction in the end. This means each system has some flexibility on when the sort keys can be generated depending on the simulation point for each emitter. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a5e001f1d59d743aa0ab94f080f01bd7b" name="a9ff3a0d25b04773ce27866f66eea39b9a5e001f1d59d743aa0ab94f080f01bd7b"></a>KeyGenAfterPostRenderOpaque&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9ae5e866cc673d8accd816936ba3e76525" name="a9ff3a0d25b04773ce27866f66eea39b9ae5e866cc673d8accd816936ba3e76525"></a>AnyKeyGenLocation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a5be97b223105b17aa32b4f3cb53c9f73" name="a9ff3a0d25b04773ce27866f66eea39b9a5be97b223105b17aa32b4f3cb53c9f73"></a>SortAfterPreRender&#160;</td><td class="fielddoc"><p>Once keys are generated, they must be sorted and the indices only need to be ready before the primitive are rendered. </p>
<p>The (frame) location only depends on whether the emitter uses opaque materials or translucent materials. It is possible to have an incorrect setup if the keys can only be generated after PostRenderOpaque() but the sorting must be ready after PreRender(). This happens with opaque Cascade emitters when simulation needs the depth buffer to do collision tests. A sort requests can have both SortIndicesAfterPreRender and SortIndicesAfterPostRenderOpaque when it is allowed to sort keys at either point. </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a36ace15a900e67ea470f504c487aa0da" name="a9ff3a0d25b04773ce27866f66eea39b9a36ace15a900e67ea470f504c487aa0da"></a>SortAfterPostRenderOpaque&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9aa74778a62c6e7a091143dbba810a7fb6" name="a9ff3a0d25b04773ce27866f66eea39b9aa74778a62c6e7a091143dbba810a7fb6"></a>AnySortLocation&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a39ce58881e43fc13193dd50be8d8360a" name="a9ff3a0d25b04773ce27866f66eea39b9a39ce58881e43fc13193dd50be8d8360a"></a>ValuesAsG16R16F&#160;</td><td class="fielddoc"><p>The sorted values can either be read as 1D or 2D, but doesn't otherwise affect the sorting implementation as long as the storage size is the same. </p>
<p>Currently it is 32 bits in both cases. Note that the sorting shader reads the indices as UInt32 (see <a class="el" href="classFParticleSortBuffers.html#aefee70603ff21887c1dc12654baa27bd" title="Initialize RHI resources.">FParticleSortBuffers::InitRHI()</a>). </p>
</td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9aa893550952d7007756585f9a6e715693" name="a9ff3a0d25b04773ce27866f66eea39b9aa893550952d7007756585f9a6e715693"></a>ValuesAsInt32&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9ff3a0d25b04773ce27866f66eea39b9a23a36eeaad01b1f76979d14135f652ea" name="a9ff3a0d25b04773ce27866f66eea39b9a23a36eeaad01b1f76979d14135f652ea"></a>AnyValueFormat&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="GPUSortManager_8h_source.html#l00094">94</a> of file <a class="el" href="GPUSortManager_8h_source.html">GPUSortManager.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a58ff6a6755410d24d26568cfaa590297" name="a58ff6a6755410d24d26568cfaa590297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ff6a6755410d24d26568cfaa590297">&#9670;&#160;</a></span>CopyUIntBufferToTargets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CopyUIntBufferToTargets </td>
          <td>(</td>
          <td class="paramtype">FRHICommandList &amp;</td>          <td class="paramname"><span class="paramname"><em>RHICmdList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ERHIFeatureLevel::Type</td>          <td class="paramname"><span class="paramname"><em>FeatureLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRHIShaderResourceView *</td>          <td class="paramname"><span class="paramname"><em>SourceSRV</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FRHIUnorderedAccessView *const *</td>          <td class="paramname"><span class="paramname"><em>TargetUAVs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> *</td>          <td class="paramname"><span class="paramname"><em>TargetSizes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>          <td class="paramname"><span class="paramname"><em>StartingOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>          <td class="paramname"><span class="paramname"><em>NumTargets</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy one uint buffer into several overlapping targets. </p>
<p>Each target is expected to be bigger than the previous one, so that copy resumes where it left. Ex : (ABCDEFGHIJK) -&gt; (ABC&ndash;, &mdash;DEFGHI-, ------&mdash;JK&mdash;) This is essentially used to manage growable buffers in cases the binding needs to be set before the final size required is known. In this scenario, the smaller buffers are temporary and only the final (biggest) buffer becomes persistent, this is why it has apparently unused space at the beginning but it will be used the next frame to hold all of the data. Note that required calls to RHICmdList.Transition need to be handled before and after this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RHICmdList</td><td>- The command list used to issue the dispatch. </td></tr>
    <tr><td class="paramname">FeatureLevel</td><td>- The current feature level, used to access the global shadermap. </td></tr>
    <tr><td class="paramname">SourceSRV</td><td>- The source uint buffer to be copied into the others. </td></tr>
    <tr><td class="paramname">TargetUAVs</td><td>- The destination overlapping uint buffers. </td></tr>
    <tr><td class="paramname">TargetSizes</td><td>- The copy size of each of the buffers. Once a buffer size is reached, the copy targets the next buffer. </td></tr>
    <tr><td class="paramname">StartingOffset</td><td>- The starting position at which the copy starts. Applies for both the source and targets. </td></tr>
    <tr><td class="paramname">NumTargets</td><td>- The number of elements in TargetUAVs and TargetSizes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae86b6871b5c891dddfea43583674630" name="aae86b6871b5c891dddfea43583674630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae86b6871b5c891dddfea43583674630">&#9670;&#160;</a></span>ENUM_CLASS_FLAGS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ENUM_CLASS_FLAGS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9">EGPUSortFlags</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Callback used by the <a class="el" href="classFGPUSortManager.html" title="A manager that handles different GPU sort tasks.">FGPUSortManager</a> to make each client system initialize the sort keys for a specific sort batch. </p>
<p>Sort batches are created when GPU sort tasks are registered in <a class="el" href="classFGPUSortManager.html#a3e679326cae8e894414ee5eabedcb8e8" title="Add a GPU sort task to process this frame.">FGPUSortManager::AddTask()</a>. Note that the system that is getting this callback must only initialize the data for the elements is has registered in this batch.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">RHICmdList</td><td>- The command list used to initiate the keys and values on GPU. </td></tr>
    <tr><td class="paramname">BatchId</td><td>- The GPUSortManager batch id (regrouping several similar sort tasks). </td></tr>
    <tr><td class="paramname">NumElementsInBatch</td><td>- The number of elements grouped in the batch (each element maps to a sort task) </td></tr>
    <tr><td class="paramname">Flags</td><td>- Details about the key precision (see <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9a6878d59f868118ac98b3fc2f3ba3a106">EGPUSortFlags::AnyKeyPrecision</a>) and the keygen location (see <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9ae5e866cc673d8accd816936ba3e76525">EGPUSortFlags::AnyKeyGenLocation</a>). </td></tr>
    <tr><td class="paramname">KeysUAV</td><td>- The UAV that holds all the initial keys used to sort the values. </td></tr>
    <tr><td class="paramname">ValuesUAV</td><td>- The UAV that holds the initial values to be sorted accordingly to the keys. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a4a3e37551b3938a562a688580e6eac00" name="a4a3e37551b3938a562a688580e6eac00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3e37551b3938a562a688580e6eac00">&#9670;&#160;</a></span>EGPUSortFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRHICommandListImmediate <a class="el" href="#a9ff3a0d25b04773ce27866f66eea39b9">EGPUSortFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUSortManager_8h_source.html#l00158">158</a> of file <a class="el" href="GPUSortManager_8h_source.html">GPUSortManager.h</a>.</p>

</div>
</div>
<a id="a5613c6c7c852953c5ac0195f5c5e83e9" name="a5613c6c7c852953c5ac0195f5c5e83e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5613c6c7c852953c5ac0195f5c5e83e9">&#9670;&#160;</a></span>int32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">FRHICommandListImmediate <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="GPUSortManager_8h_source.html#l00158">158</a> of file <a class="el" href="GPUSortManager_8h_source.html">GPUSortManager.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="classFGPUSortManager_1_1FValueBuffer.html#a80e6b3a4da3cc0e56c898edac24d45ca">FGPUSortManager::FValueBuffer::FValueBuffer()</a>, <a class="el" href="classFGPUSortManager.html#a3e679326cae8e894414ee5eabedcb8e8">FGPUSortManager::AddTask()</a>, <a class="el" href="structFGPUSortManager_1_1FDynamicValueBuffer.html#a1e096ba4fc44d86e84f3c48bf4382a22">FGPUSortManager::FDynamicValueBuffer::Allocate()</a>, <a class="el" href="classFGPUSortManager_1_1FValueBuffer.html#ae1fa1502b48b449a22dc6e28f274d103">FGPUSortManager::FValueBuffer::Allocate()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00319">FGPUSortManager::FDynamicValueBuffer::GetAllocatedCount()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00391">FGPUSortManager::FSortBatch::GetAllocatedValueCount()</a>, <a class="el" href="classFGPUSortManager.html#a2a4e370b8df4d7faed9433925b7c4d84">FGPUSortManager::GetDynamicValueBufferFromPool()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00054">FParticleSortBuffers::GetKeyBufferUAV()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00071">FParticleSortBuffers::GetSize()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00064">FParticleSortBuffers::GetSortedVertexBufferRHI()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00317">FGPUSortManager::FDynamicValueBuffer::GetUsedCount()</a>, <a class="el" href="GPUSortManager_8h_source.html#l00389">FGPUSortManager::FSortBatch::GetUsedValueCount()</a>, and <a class="el" href="GPUSortManager_8h_source.html#l00042">FParticleSortBuffers::SetBufferSize()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_7536b172fbd480bfd146a1b1acd6856b.html">Runtime</a></li><li class="navelem"><a href="dir_fdf6aa5c3cf3805bb958134448d60562.html">Engine</a></li><li class="navelem"><a href="dir_1d06a51bfc871a6a1823440d0d72725c.html">Public</a></li><li class="navelem"><a href="GPUSortManager_8h.html">GPUSortManager.h</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Unreal Engine 5.6 C++ API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
