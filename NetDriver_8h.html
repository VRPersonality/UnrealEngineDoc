<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unreal Engine 5.6 C++ API: Runtime/Engine/Classes/Engine/NetDriver.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Unreal Engine 5.6 C++ API<span id="projectnumber">&#160;5.6.0</span>
   </div>
   <div id="projectbrief">C++ API documentation for Unreal Engine 5.6</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('NetDriver_8h.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">NetDriver.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="CoreMinimal_8h_source.html">CoreMinimal.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="EngineBaseTypes_8h_source.html">Engine/EngineBaseTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="EngineTypes_8h_source.html">Engine/EngineTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NetworkMetricsDatabase_8h_source.html">Net/NetworkMetricsDatabase.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="IConsoleManager_8h_source.html">HAL/IConsoleManager.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="RandomStream_8h_source.html">Math/RandomStream.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ObjectMacros_8h_source.html">UObject/ObjectMacros.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="UObjectGlobals_8h_source.html">UObject/UObjectGlobals.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Object_8h_source.html">UObject/Object.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ObjectKey_8h_source.html">UObject/ObjectKey.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NetworkGuid_8h_source.html">Misc/NetworkGuid.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="CoreNet_8h_source.html">UObject/CoreNet.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="Runtime_2Engine_2Classes_2Engine_2Channel_8h_source.html">Channel.h</a>&quot;</code><br />
<code>#include &quot;Net/Core/Connection/ConnectionHandle.h&quot;</code><br />
<code>#include &quot;Net/Core/Misc/DDoSDetection.h&quot;</code><br />
<code>#include &quot;IPAddress.h&quot;</code><br />
<code>#include &quot;<a class="el" href="NetAnalyticsTypes_8h_source.html">Net/NetAnalyticsTypes.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="NetConnectionIdHandler_8h_source.html">Net/NetConnectionIdHandler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="LowLevelMemTracker_8h_source.html">HAL/LowLevelMemTracker.h</a>&quot;</code><br />
<code>#include &quot;NetDriver.generated.h&quot;</code><br />
</div>
<p><a href="NetDriver_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:ConsiderListUpdateParams" id="r_ConsiderListUpdateParams"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structConsiderListUpdateParams.html">ConsiderListUpdateParams</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The structure to pass to the OnConsiderListUpdate delegate.  <a href="structConsiderListUpdateParams.html#details">More...</a><br /></td></tr>
<tr class="memitem:FActorDestructionInfo" id="r_FActorDestructionInfo"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFActorDestructionInfo.html">FActorDestructionInfo</a></td></tr>
<tr class="memitem:FActorPriority" id="r_FActorPriority"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFActorPriority.html">FActorPriority</a></td></tr>
<tr class="memitem:FCompareFActorPriority" id="r_FCompareFActorPriority"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFCompareFActorPriority.html">FCompareFActorPriority</a></td></tr>
<tr class="memitem:FDisconnectedClient" id="r_FDisconnectedClient"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFDisconnectedClient.html">FDisconnectedClient</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about disconnected client NetConnection's.  <a href="structFDisconnectedClient.html#details">More...</a><br /></td></tr>
<tr class="memitem:UE_3A_3ANet_3A_3AFScopedIgnoreStaticActorDestruction" id="r_UE_3A_3ANet_3A_3AFScopedIgnoreStaticActorDestruction"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUE_1_1Net_1_1FScopedIgnoreStaticActorDestruction.html">UE::Net::FScopedIgnoreStaticActorDestruction</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:UE" id="r_UE"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUE.html">UE</a></td></tr>
<tr class="memdesc:namespaceUE"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility functions for applying transformations to meshes. <br /></td></tr>
<tr class="memitem:UE_3A_3ANet" id="r_UE_3A_3ANet"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUE_1_1Net.html">UE::Net</a></td></tr>
<tr class="memdesc:namespaceUE_1_1Net"><td class="mdescLeft">&#160;</td><td class="mdescRight">Responsible for creating headers allowing remote factories to spawn replicated actors. <br /></td></tr>
<tr class="memitem:UE_3A_3ANet_3A_3APrivate" id="r_UE_3A_3ANet_3A_3APrivate"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUE_1_1Net_1_1Private.html">UE::Net::Private</a></td></tr>
<tr class="memdesc:namespaceUE_1_1Net_1_1Private"><td class="mdescLeft">&#160;</td><td class="mdescRight">===================== NetSerialize and NetDeltaSerialize customization. <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-define-members" class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5967c5cc884e097abb54e67ae9d924f1" id="r_a5967c5cc884e097abb54e67ae9d924f1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5967c5cc884e097abb54e67ae9d924f1">DO_ENABLE_NET_TEST</a>&#160;&#160;&#160;!(UE_BUILD_SHIPPING)</td></tr>
<tr class="memitem:af23ad1d2cc797f5df30d1b092bb365c8" id="r_af23ad1d2cc797f5df30d1b092bb365c8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af23ad1d2cc797f5df30d1b092bb365c8">NET_DEBUG_RELEVANT_ACTORS</a>&#160;&#160;&#160;!(UE_BUILD_SHIPPING || <a class="el" href="Build_8h.html#a13ac897276c9ba4b3e762100532e5c7a">UE_BUILD_TEST</a>)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa8360487ca9ff63269e9f5fcb8943c96" id="r_aa8360487ca9ff63269e9f5fcb8943c96"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa8360487ca9ff63269e9f5fcb8943c96">FConnectionMap</a> = <a class="el" href="classTMap.html">TMap</a>&lt;<a class="el" href="classTSharedRef.html">TSharedRef</a>&lt;const FInternetAddr&gt;, <a class="el" href="structTObjectPtr.html">TObjectPtr</a>&lt;UNetConnection&gt;, <a class="el" href="classFDefaultSetAllocator.html">FDefaultSetAllocator</a>, FInternetAddrConstKeyMapFuncs&lt;<a class="el" href="structTObjectPtr.html">TObjectPtr</a>&lt;UNetConnection&gt;&gt;&gt;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a04e8cda463c77a45f3cb0f77e27aeff8" id="r_a04e8cda463c77a45f3cb0f77e27aeff8"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8">EProcessRemoteFunctionFlags</a> : uint32 { <a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8aba1427fd1dfed4573e603bcf4dd1876a">ReplicatedActor</a> = 1 &lt;&lt; 0
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3e2a3628285463a90c721957e05a39bf" id="r_a3e2a3628285463a90c721957e05a39bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8c7a127091efbdfc5a16939041653e05">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUE_1_1Net.html#a3e2a3628285463a90c721957e05a39bf">UE::Net::CountReplicatedSubObjectsOfActor</a> (AActor *<a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8aba1427fd1dfed4573e603bcf4dd1876a">ReplicatedActor</a>)</td></tr>
<tr class="memdesc:a3e2a3628285463a90c721957e05a39bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function that counts the number of replicated subobjects owned by a given actor.  <br /></td></tr>
<tr class="memitem:a5f03fb6d413d7ea3995edfbaccd6d56b" id="r_a5f03fb6d413d7ea3995edfbaccd6d56b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f03fb6d413d7ea3995edfbaccd6d56b">DECLARE_DELEGATE_RetVal</a> (<a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>, FShouldSkipRepNotifies)</td></tr>
<tr class="memdesc:a5f03fb6d413d7ea3995edfbaccd6d56b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegate for hooking ShouldSkipRepNotifies.  <br /></td></tr>
<tr class="memitem:afb5cd65c4540cfa86941c7e00af2967b" id="r_afb5cd65c4540cfa86941c7e00af2967b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb5cd65c4540cfa86941c7e00af2967b">DECLARE_DELEGATE_SevenParams</a> (FOnSendRPC, AActor *, <a class="el" href="classUFunction.html">UFunction</a> *, void *, <a class="el" href="structFOutParmRec.html">FOutParmRec</a> *, <a class="el" href="structFFrame.html">FFrame</a> *, <a class="el" href="classUObject.html">UObject</a> *, <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> &amp;)</td></tr>
<tr class="memdesc:afb5cd65c4540cfa86941c7e00af2967b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delegate for hooking ProcessRemoteFunction (used by NetcodeUnitTest)  <br /></td></tr>
<tr class="memitem:aa74342dc9cb720b0531b0e737bde55d2" id="r_aa74342dc9cb720b0531b0e737bde55d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa74342dc9cb720b0531b0e737bde55d2">DECLARE_DELEGATE_ThreeParams</a> (FOnConsiderListUpdate, const <a class="el" href="structConsiderListUpdateParams.html">ConsiderListUpdateParams</a> &amp;UpdateParams, <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &amp;OutUpdated, const <a class="el" href="classTArray.html">TArray</a>&lt; <a class="el" href="structFNetworkObjectInfo.html">FNetworkObjectInfo</a> * &gt; &amp;ConsiderList)</td></tr>
<tr class="memitem:ac731746c70ed8c5920e24bc833a2dca3" id="r_ac731746c70ed8c5920e24bc833a2dca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac731746c70ed8c5920e24bc833a2dca3">ENUM_CLASS_FLAGS</a> (<a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8">EProcessRemoteFunctionFlags</a>)</td></tr>
<tr class="memitem:a8f23e51a823cfc525af65ce1c320d172" id="r_a8f23e51a823cfc525af65ce1c320d172"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f23e51a823cfc525af65ce1c320d172">LLM_DECLARE_TAG_API</a> (NetDriver, 1)</td></tr>
<tr class="memdesc:a8f23e51a823cfc525af65ce1c320d172"><td class="mdescLeft">&#160;</td><td class="mdescRight">NetDrivers, NetConnections, and Channels.  <br /></td></tr>
<tr class="memitem:a48adfe544c542eeb213019007a789023" id="r_a48adfe544c542eeb213019007a789023"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUE_1_1Net.html#a48adfe544c542eeb213019007a789023">UE::Net::ShouldIgnoreStaticActorDestruction</a> ()</td></tr>
<tr class="memitem:a01eee029b4ab82a1e6ea8d1707a29ff1" id="r_a01eee029b4ab82a1e6ea8d1707a29ff1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01eee029b4ab82a1e6ea8d1707a29ff1">USTRUCT</a> () struct FPacketSimulationSettings</td></tr>
<tr class="memdesc:a01eee029b4ab82a1e6ea8d1707a29ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Holds the packet simulation settings in one place.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a4e2d462dfccd47fb522a65711bb8090c" id="r_a4e2d462dfccd47fb522a65711bb8090c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTAutoConsoleVariable.html">TAutoConsoleVariable</a>&lt; <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e2d462dfccd47fb522a65711bb8090c">CVarNetAllowEncryption</a></td></tr>
<tr class="memitem:ab11ff6e2f11d151803b3954d03e96ba4" id="r_ab11ff6e2f11d151803b3954d03e96ba4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8c7a127091efbdfc5a16939041653e05">uint32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab11ff6e2f11d151803b3954d03e96ba4">GNetOutBytes</a></td></tr>
<tr class="memitem:a2bdba4d0ee86d891c1651403ae640f5b" id="r_a2bdba4d0ee86d891c1651403ae640f5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2bdba4d0ee86d891c1651403ae640f5b">GNumClientConnections</a></td></tr>
<tr class="memitem:ab9f5d2ef2b989f1e131b626f4b1a0b60" id="r_ab9f5d2ef2b989f1e131b626f4b1a0b60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab9f5d2ef2b989f1e131b626f4b1a0b60">GNumClientUpdateLevelVisibility</a></td></tr>
<tr class="memitem:ad754b19225fefedbea0309260eea3383" id="r_ad754b19225fefedbea0309260eea3383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad754b19225fefedbea0309260eea3383">GNumReplicateActorCalls</a></td></tr>
<tr class="memitem:a5578d92916ca072f72e9c2d0e750f6b0" id="r_a5578d92916ca072f72e9c2d0e750f6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5578d92916ca072f72e9c2d0e750f6b0">GNumSaturatedConnections</a></td></tr>
<tr class="memitem:a7b38cd1345758a28185a74c0241c9f96" id="r_a7b38cd1345758a28185a74c0241c9f96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b38cd1345758a28185a74c0241c9f96">GNumSharedSerializationHit</a></td></tr>
<tr class="memitem:ae807dc2dfc59b9304cfe351adfac788f" id="r_ae807dc2dfc59b9304cfe351adfac788f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae807dc2dfc59b9304cfe351adfac788f">GNumSharedSerializationMiss</a></td></tr>
<tr class="memitem:acaeef46662f1dccf6e8a0d6984b4ebb6" id="r_acaeef46662f1dccf6e8a0d6984b4ebb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acaeef46662f1dccf6e8a0d6984b4ebb6">GReceiveRPCTimingEnabled</a></td></tr>
<tr class="memitem:a9964aa65b82c75951c26a548be9a6730" id="r_a9964aa65b82c75951c26a548be9a6730"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9964aa65b82c75951c26a548be9a6730">GReplicateActorTimeSeconds</a></td></tr>
<tr class="memitem:ac4e3ff8a280ee64cec7a7a531659b04a" id="r_ac4e3ff8a280ee64cec7a7a531659b04a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e3ff8a280ee64cec7a7a531659b04a">GReplicateActorTimingEnabled</a></td></tr>
<tr class="memitem:a5cc76c080a44c39febec9c83a5ce3248" id="r_a5cc76c080a44c39febec9c83a5ce3248"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cc76c080a44c39febec9c83a5ce3248">GReplicationGatherPrioritizeTimeSeconds</a></td></tr>
<tr class="memitem:ae4da56caded8b454dbf54e0a9224e84c" id="r_ae4da56caded8b454dbf54e0a9224e84c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae4da56caded8b454dbf54e0a9224e84c">GServerReplicateActorTimeSeconds</a></td></tr>
<tr class="memitem:a4087ee011bcac1e0b760645693f767ac" id="r_a4087ee011bcac1e0b760645693f767ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUE_1_1Net_1_1Private.html#a4087ee011bcac1e0b760645693f767ac">UE::Net::Private::SerializeNewActorOverrideLevel</a></td></tr>
<tr class="memdesc:a4087ee011bcac1e0b760645693f767ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow other internal systems to check this cvar.  <br /></td></tr>
</table>
<a name="doc-define-members" id="doc-define-members"></a><h2 id="header-doc-define-members" class="groupheader">Macro Definition Documentation</h2>
<a id="a5967c5cc884e097abb54e67ae9d924f1" name="a5967c5cc884e097abb54e67ae9d924f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5967c5cc884e097abb54e67ae9d924f1">&#9670;&#160;</a></span>DO_ENABLE_NET_TEST</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define DO_ENABLE_NET_TEST&#160;&#160;&#160;!(UE_BUILD_SHIPPING)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NetDriver_8h_source.html#l00446">446</a> of file <a class="el" href="NetDriver_8h_source.html">NetDriver.h</a>.</p>

</div>
</div>
<a id="af23ad1d2cc797f5df30d1b092bb365c8" name="af23ad1d2cc797f5df30d1b092bb365c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23ad1d2cc797f5df30d1b092bb365c8">&#9670;&#160;</a></span>NET_DEBUG_RELEVANT_ACTORS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define NET_DEBUG_RELEVANT_ACTORS&#160;&#160;&#160;!(UE_BUILD_SHIPPING || <a class="el" href="Build_8h.html#a13ac897276c9ba4b3e762100532e5c7a">UE_BUILD_TEST</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NetDriver_8h_source.html#l00449">449</a> of file <a class="el" href="NetDriver_8h_source.html">NetDriver.h</a>.</p>

</div>
</div>
<a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="aa8360487ca9ff63269e9f5fcb8943c96" name="aa8360487ca9ff63269e9f5fcb8943c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8360487ca9ff63269e9f5fcb8943c96">&#9670;&#160;</a></span>FConnectionMap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#aa8360487ca9ff63269e9f5fcb8943c96">FConnectionMap</a> = <a class="el" href="classTMap.html">TMap</a>&lt;<a class="el" href="classTSharedRef.html">TSharedRef</a>&lt;const FInternetAddr&gt;, <a class="el" href="structTObjectPtr.html">TObjectPtr</a>&lt;UNetConnection&gt;, <a class="el" href="classFDefaultSetAllocator.html">FDefaultSetAllocator</a>, FInternetAddrConstKeyMapFuncs&lt;<a class="el" href="structTObjectPtr.html">TObjectPtr</a>&lt;UNetConnection&gt;&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="NetDriver_8h_source.html#l00381">381</a> of file <a class="el" href="NetDriver_8h_source.html">NetDriver.h</a>.</p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a04e8cda463c77a45f3cb0f77e27aeff8" name="a04e8cda463c77a45f3cb0f77e27aeff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04e8cda463c77a45f3cb0f77e27aeff8">&#9670;&#160;</a></span>EProcessRemoteFunctionFlags</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8">EProcessRemoteFunctionFlags</a> : <a class="el" href="Platform_8h.html#a8c7a127091efbdfc5a16939041653e05">uint32</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a04e8cda463c77a45f3cb0f77e27aeff8a6adf97f83acf6453d4a6a4b1070f3754" name="a04e8cda463c77a45f3cb0f77e27aeff8a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a04e8cda463c77a45f3cb0f77e27aeff8aba1427fd1dfed4573e603bcf4dd1876a" name="a04e8cda463c77a45f3cb0f77e27aeff8aba1427fd1dfed4573e603bcf4dd1876a"></a>ReplicatedActor&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="NetDriver_8h_source.html#l00774">774</a> of file <a class="el" href="NetDriver_8h_source.html">NetDriver.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a5f03fb6d413d7ea3995edfbaccd6d56b" name="a5f03fb6d413d7ea3995edfbaccd6d56b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f03fb6d413d7ea3995edfbaccd6d56b">&#9670;&#160;</a></span>DECLARE_DELEGATE_RetVal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECLARE_DELEGATE_RetVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FShouldSkipRepNotifies</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delegate for hooking ShouldSkipRepNotifies. </p>

</div>
</div>
<a id="afb5cd65c4540cfa86941c7e00af2967b" name="afb5cd65c4540cfa86941c7e00af2967b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb5cd65c4540cfa86941c7e00af2967b">&#9670;&#160;</a></span>DECLARE_DELEGATE_SevenParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECLARE_DELEGATE_SevenParams </td>
          <td>(</td>
          <td class="paramtype">FOnSendRPC</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">AActor *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUFunction.html">UFunction</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFOutParmRec.html">FOutParmRec</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structFFrame.html">FFrame</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUObject.html">UObject</a> *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> &amp;</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delegate for hooking ProcessRemoteFunction (used by NetcodeUnitTest) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Actor</td><td>The actor the RPC will be called in </td></tr>
    <tr><td class="paramname">Function</td><td>The RPC to call </td></tr>
    <tr><td class="paramname">Parameters</td><td>The parameters data blob </td></tr>
    <tr><td class="paramname">OutParms</td><td>Out parameter information (irrelevant for RPC's) </td></tr>
    <tr><td class="paramname">Stack</td><td>The script stack </td></tr>
    <tr><td class="paramname">SubObject</td><td>The sub-object the RPC is being called in (if applicable) </td></tr>
    <tr><td class="paramname">bBlockSendRPC</td><td>Whether or not to block sending of the RPC (defaults to false) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa74342dc9cb720b0531b0e737bde55d2" name="aa74342dc9cb720b0531b0e737bde55d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74342dc9cb720b0531b0e737bde55d2">&#9670;&#160;</a></span>DECLARE_DELEGATE_ThreeParams()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECLARE_DELEGATE_ThreeParams </td>
          <td>(</td>
          <td class="paramtype">FOnConsiderListUpdate</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structConsiderListUpdateParams.html">ConsiderListUpdateParams</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>UpdateParams</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OutUpdated</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTArray.html">TArray</a>&lt; <a class="el" href="structFNetworkObjectInfo.html">FNetworkObjectInfo</a> * &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ConsiderList</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac731746c70ed8c5920e24bc833a2dca3" name="ac731746c70ed8c5920e24bc833a2dca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac731746c70ed8c5920e24bc833a2dca3">&#9670;&#160;</a></span>ENUM_CLASS_FLAGS()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ENUM_CLASS_FLAGS </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a04e8cda463c77a45f3cb0f77e27aeff8">EProcessRemoteFunctionFlags</a></td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="AnimMontage_8h_source.html#l00621">MinimalAPI</a>.</p>

</div>
</div>
<a id="a8f23e51a823cfc525af65ce1c320d172" name="a8f23e51a823cfc525af65ce1c320d172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f23e51a823cfc525af65ce1c320d172">&#9670;&#160;</a></span>LLM_DECLARE_TAG_API()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">LLM_DECLARE_TAG_API </td>
          <td>(</td>
          <td class="paramtype">NetDriver</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">1</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>NetDrivers, NetConnections, and Channels. </p>
<p>UNetDrivers are responsible for managing sets of UNetConnections, and data that can be shared between them. There is typically a relatively small number of UNetDrivers for a given game. These may include:</p><ul>
<li>The Game NetDriver, responsible for standard game network traffic.</li>
<li>The Demo NetDriver, responsible for recording or playing back previously recorded game data. This is how Replays work.</li>
<li>The Beacon NetDriver, responsible for network traffic that falls outside of "normal" gameplay traffic.</li>
</ul>
<p>Custom NetDrivers can also be implemented by games or applications and used. NetConnections represent individual clients that are connected to a game (or more generally, to a NetDriver).</p>
<p>End point data isn't directly handled by NetConnections. Instead NetConnections will route data to Channels. Every NetConnection will have its own set of channels.</p>
<p>Common types of channels:</p>
<ul>
<li>A Control Channel is used to send information regarding state of a connection (whether or not the connection should close, etc.)</li>
<li>A Voice Channel may be used to send voice data between client and server.</li>
<li>A Unique Actor Channel will exist for every Actor replicated from the server to the client.</li>
</ul>
<p>Custom Channels can also be created and used for specialized purposes (although, this isn't very common).</p>
<p>Game Net Drivers, Net Connections, and Channels</p>
<p>Under normal circumstances, there will exist only a single NetDriver (created on Client and Server) for "standard" game traffic and connections.</p>
<p>The Server NetDriver will maintain a list of NetConnections, each representing a player that is in the game. It is responsible for replicating Actor Data.</p>
<p>Client NetDrivers will have a single NetConnection representing the connection to the Server.</p>
<p>On both Server and Client, the NetDriver is responsible for receiving Packets from the network and passing those to the appropriate NetConnection (and establishing new NetConnections when necessary).</p>
<p>Initiating Connections / Handshaking Flow.</p>
<p>UIpNetDriver and UIpConnection (or derived classes) are the engine defaults for almost every platform, and everything below describes how they establish and manage connections. These processes can differ between implementations of NetDriver, however.</p>
<p>Both Server and Clients will have have their own NetDrivers, and all <a class="el" href="namespaceUE.html" title="Utility functions for applying transformations to meshes.">UE</a> Replicated Game traffic will be sent by or Received from the IpNetDriver. This traffic also includes logic for establishing connections, and re-establishing connections when something goes wrong.</p>
<p>Handshaking is split across a couple of different places: NetDriver, PendingNetGame, World, PacketHandlers, and maybe others. The split is due to having separate needs, things such as: determining whether or not an incoming connection is sending data in "UE-Protocol", determining whether or not an address appears to be malicious, whether or not a given client has the correct version of a game, etc.</p>
<p>Startup and Handshaking</p>
<p>Whenenever a server Loads a map (via UEngine::LoadMap), we will make a call into UWorld::Listen. That code is responsible for creating the main Game Net Driver, parsing out settings, and calling UNetDriver::InitListen. Ultimately, that code will be responsible for figuring out what how exactly we listen for client connections. For example, in IpNetDriver, that is where we determine the IP / Port we will bind to by calls to our configured Socket Subsystem (see ISocketSubsystem::GetLocalBindAddresses and ISocketSubsystem::BindNextPort).</p>
<p>Once the server is listening, it's ready to start accepting client connections.</p>
<p>Whenever a client wants to Join a server, they will first establish a new UPendingNetGame in UEngine::Browse with the server's IP. UPendingNetGame::Initialize and UPendingNetGame::InitNetDriver are responsible for initializing settings and setting up the NetDriver respectively. Clients will immediately setup a UNetConnection for the server as a part of this initialization, and will start sending data to the server on that connection, initiating the handshaking process.</p>
<p>On both Clients and Server, UNetDriver::TickDispatch is typically responsible for receiving network data. Typically, when we receive a packet, we inspect its address and see whether or not it's from a connection we already know about. We determine whether or not we've established a connection for a given source address by simply keeping a map from FInternetAddr to UNetConnection.</p>
<p>If a packet is from a connection that's already established, we pass the packet along to the connection via UNetConnection::ReceivedRawPacket. If a packet is not from a connection that's already established, we treat is as "connectionless" and begin the handshaking process.</p>
<p>See StatelessConnectionHandlerComponent.cpp for details on how this handshaking works.</p>
<p>UWorld / UPendingNetGame / <a class="el" href="classAGameModeBase.html">AGameModeBase</a> Startup and Handshaking</p>
<p>After the UNetDriver and UNetConnection have completed their handshaking process on Client and Server, UPendingNetGame::SendInitialJoin will be called on the Client to kick off game level handshaking.</p>
<p>Game Level Handshaking is done through a more structured and involved set of FNetControlMessages. The full set of control messages can be found in <a class="el" href="DataChannel_8h.html">DataChannel.h</a>.</p>
<p>Most of the work for handling these control messages are done either in UWorld::NotifyControlMessage, and UPendingNetGame::NotifyControlMessage. Briefly, the flow looks like this:</p>
<p>Client's UPendingNetGame::SendInitialJoin sends NMT_Hello.</p>
<p>Server's UWorld::NotifyControlMessage receives NMT_Hello, sends NMT_Challenge.</p>
<p>Client's UPendingNetGame::NotifyControlMessage receives NMT_Challenge, and sends back data in NMT_Login.</p>
<p>Server's UWorld::NotifyControlMessage receives NMT_Login, verifies challenge data, and then calls <a class="el" href="classAGameModeBase.html#a50939fffd5607172ad75c90c0845375c" title="Accept or reject a player attempting to join the server.">AGameModeBase::PreLogin</a>. If PreLogin doesn't report any errors, Server calls UWorld::WelcomePlayer, which call <a class="el" href="classAGameModeBase.html#a5676cd1ffa7c3fa7807596fe125c4abc" title="Allows game to send network messages to provide more information to the client joining the game via N...">AGameModeBase::GameWelcomePlayer</a>, and send NMT_Welcome with map information.</p>
<p>Client's UPendingNetGame::NotifyControlMessage receives NMT_Welcome, reads the map info (so it can start loading later), and sends an NMT_NetSpeed message with the configured Net Speed of the client.</p>
<p>Server's UWorld::NotifyControlMessage receives NMT_NetSpeed, and adjusts the connections Net Speed appropriately.</p>
<p>At this point, the handshaking is considered to be complete, and the player is fully connected to the game. Depending on how long it takes to load the map, the client could still receive some non-handshake control messages on UPendingNetGame before control transitions to UWorld.</p>
<p>There are also additional steps for handling Encryption when desired.</p>
<p>Reestablishing Lost Connections</p>
<p>Throughout the course of a game, it's possible for connections to be lost for a number of reasons. Internet could drop out, users could switch from LTE to WIFI, they could leave a game, etc.</p>
<p>If the server initiated one of these disconnects, or is otherwise aware of it (due to a timeout or error), then the disconnect will be handled by closing the UNetConnection and notifying the game. At that point, it's up to a game to decide whether or not they support Join In Progress or Rejoins. If the game does support it, we will completely restart the handshaking flow as above.</p>
<p>If something just briefly interrupts the client's connection, but the server is never made aware, then the engine / game will typically recover automatically (albeit with some packet loss / lag spike).</p>
<p>However, if the Client's IP Address or Port change for any reason, but the server isn't aware of this, then we will begin a recovery process by redoing the low level handshake. In this case, game code will not be alerted.</p>
<p>This process is covered in StatlessConnectionHandlerComponent.cpp.</p>
<p>Data Transmission</p>
<p>Game NetConnections and NetDrivers are generally agnostic to the underlying communication method / technology used. That is is left up to subclasses to decide (classes such as UIpConnection / UIpNetDriver or UWebSocketConnection / UWebSocketNetDriver).</p>
<p>Instead, UNetDriver and UNetConnection work with Packets and Bunches.</p>
<p>Packets are blobs of data that are sent between pairs of NetConnections on Host and Client. Packets consist of meta data about the packet (such as header information and acknowledgments), and Bunches.</p>
<p>Bunches are blobs of data that are sent between pairs of Channels on Host and Client. When a Connection receives a Packet, that packet will be disassembled into individual bunches. Those bunches are then passed along to individual Channels to be processed further.</p>
<p>A Packet may contain no bunches, a single bunch, or multiple bunches. Because size limits for bunches may be larger than the size limits of a single packet, <a class="el" href="namespaceUE.html" title="Utility functions for applying transformations to meshes.">UE</a> supports the notion of partial bunches.</p>
<p>When a bunch is too large, before transmission we will slice it into a number of smaller bunches. these bunches will be flagged as PartialInitial, Partial, or PartialFinal. Using this information, we can reassemble the bunches on the receiving end.</p>
<p>Example: Client RPC to Server.</p><ul>
<li>Client makes a call to Server_RPC.</li>
<li>That request is forwarded (via NetDriver and NetConnection) to the Actor Channel that owns the Actor on which the RPC was called.</li>
<li>The Actor Channel will serialize the RPC Identifier and parameters into a Bunch. The Bunch will also contain the ID of its Actor Channel.</li>
<li>The Actor Channel will then request the NetConnection send the Bunch.</li>
<li>Later, the NetConnection will assemble this (and other) data into a Packet which it will send to the server.</li>
<li>On the Server, the Packet will be received by the NetDriver.</li>
<li>The NetDriver will inspect the Address that sent the Packet, and hand the Packet over to the appropriate NetConnection.</li>
<li>The NetConnection will disassemble the Packet into its Bunches (one by one).</li>
<li>The NetConnection will use the Channel ID on the bunch to Route the bunch to the corresponding Actor Channel.</li>
<li>The ActorChannel will them disassemble the bunch, see it contains RPC data, and use the RPC ID and serialized parameters to call the appropriate function on the Actor.</li>
</ul>
<p>Reliability and Retransmission</p>
<p><a class="el" href="namespaceUE.html" title="Utility functions for applying transformations to meshes.">UE</a> Networking typically assumes reliability isn't guaranteed by the underlying network protocol. Instead, it implements its own reliability and retransmission of both packets and bunches.</p>
<p>When a NetConnection is established, it will establish a Sequence Number for its packets and bunches. These can either be fixed, or randomized (when randomized, the sequence will be sent by the server).</p>
<p>The packet number is per NetConnection, incremented for every packet sent, every packet will include its packet number, and we will never retransmit a packet with the same packet number.</p>
<p>The bunch number is per Channel, incremented for every <b>reliable</b> bunch sent, and every <b>reliable</b> bunch will include its bunch number. Unlike packets, though, exact (reliable) bunches may be retransmitted. This means we will resend bunches with the same bunch number.</p>
<p>Note, throughout the code what are described above as both bunch numbers and packet numbers are commonly referred to just as sequence numbers. We make the distinction here for clearer understanding.</p>
<p>&mdash; Detecting Incoming Dropped Packets &mdash;</p>
<p>By assigning packet numbers, we can easily detect when incoming packets are lost. This is done simply by taking the difference between the last successfully received packet number, and the packet number of the current packet being processed.</p>
<p>Under good conditions, all packets will be received in the order they are sent. This means that the difference will be +1.</p>
<p>If the difference is greater than 1, that indicates that we missed some packets. We will just assume that the missing packets were dropped, but consider the current packet to have been successfully received, and use its number going forward.</p>
<p>If the difference is negative (or 0), that indicates that we either received some packets out of order, or an external service is trying to resend data to us (remember, the engine will not reuse sequence numbers).</p>
<p>In either case, the engine will typically ignore the missing or invalid packets, and will not send ACKs for them.</p>
<p>We do have methods for "fixing" out of order packets that are received on the same frame. When enabled, if we detect missing packets (difference &gt; 1), we won't process the current packet immediately. Instead, it will add it to a queue. The next time we receive a packet successfully (difference == 1), we will see if the head of our queue is properly ordered. If so, we will process it, otherwise we will continue receiving packets.</p>
<p>Once we've read all packets that are currently available, we will flush this queue processing any remaining packets. Anything that's missing at this point will be assumed to have been dropped.</p>
<p>Every packet successfully received will have its packet number sent back to the sender as an acknowledgment (ACK).</p>
<p>&mdash; Detecting Outgoing Dropped Packets &mdash;</p>
<p>As mentioned above, whenever a packet is received successfully the recipient will send back an ACK. These ACKs will contain the packet numbers of successfully received packets, in sequence order.</p>
<p>Similar to how the recipient tracks the packet number, the sender will track the highest ACKed packet number.</p>
<p>When ACKs are being processed, any ACK below our last received ACK is ignored and any gaps in packet numbers are considered Not Acknowledged (NAKed).</p>
<p>It is the sender's responsibility to handle these ACKs and NAKs and resend any missing data. The new data will be added to new outgoing packets (again, we will not resend packets we've already sent, or reuse packet sequence numbers).</p>
<p>&mdash; Resending Missing Data &mdash;</p>
<p>As mentioned above, packets alone don't contain useful game data. Instead, it's the bunches that comprise them that have meaningful data.</p>
<p>Bunches can either be marked as Reliable or Unreliable.</p>
<p>The engine will make no attempt at resending unreliable bunches if they are dropped. Therefore, if bunches are marked unreliable, the game / engine should be able to continue without them, or external retry mechanisms must be put in place, or the data must be sent redundantly. Therefore, everything below only applies to reliable bunches.</p>
<p>However, the engine will attempt to resend reliable bunches. Whenever a reliable bunch is sent, it will be added to a list of un-ACKed reliable bunches. If we receive a NAK for a packet that contained the bunch, the engine will retransmit an exact copy of that bunch. Note, because bunches may be partial, dropping even a single partial bunch will result in retransmission of the entire bunch. When all packets containing a bunch have been ACKed, we will remove it from the list.</p>
<p>Similar to packets, we will compare the bunch number for received reliable bunches to the last successfully received bunch. If we detect that the difference is negative, we simply ignore the bunch. If the difference is greater than one, we will assume we missed a bunch. Unlike packet handling, we will not discard this data. Instead, we will queue the bunch and pause processing of <b>any</b> bunches, reliable or unreliable. Processing will not be resumed until we detect have received the missing bunches, at which point we will process them, and then start processing our queued bunches. Any new bunches that are received while waiting for the missing bunches, or while we still have any bunches in our queue, will be added to the queue instead of being processed immediately. </p>

<p class="reference">References <a class="el" href="GenericPlatformMisc_8h_source.html#l00294">Error</a>.</p>

</div>
</div>
<a id="a01eee029b4ab82a1e6ea8d1707a29ff1" name="a01eee029b4ab82a1e6ea8d1707a29ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01eee029b4ab82a1e6ea8d1707a29ff1">&#9670;&#160;</a></span>USTRUCT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">USTRUCT </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Holds the packet simulation settings in one place. </p>
<p>Used to specify properties of a channel type.</p>
<p>Used to configure the replication system default values. </p>
<p>When set, will cause calls to FlushNet to drop packets. Value is treated as % of packets dropped (i.e. 0 = None, 100 = All). No general pattern / ordering is guaranteed. Clamped between 0 and 100.</p>
<p>Works with all other settings.</p>
<p>Sets the maximum size of packets in bytes that will be dropped according to the PktLoss setting. Default is INT_MAX.</p>
<p>Works with all other settings.</p>
<p>Sets the minimum size of packets in bytes that will be dropped according to the PktLoss setting. Default is 0.</p>
<p>Works with all other settings.</p>
<p>When set, will cause calls to FlushNet to change ordering of packets at random. Value is treated as a bool (i.e. 0 = False, anything else = True). This works by randomly selecting packets to be delayed until a subsequent call to FlushNet.</p>
<p>Takes precedence over PktDup and PktLag.</p>
<p>When set, will cause calls to FlushNet to duplicate packets. Value is treated as % of packets duplicated (i.e. 0 = None, 100 = All). No general pattern / ordering is guaranteed. Clamped between 0 and 100.</p>
<p>Cannot be used with PktOrder or PktLag.</p>
<p>When set, will cause calls to FlushNet to delay packets. Value is treated as millisecond lag.</p>
<p>Cannot be used with PktOrder.</p>
<p>When set, will cause PktLag to use variable lag instead of constant. Value is treated as millisecond lag range (e.g. -GivenVariance &lt;= 0 &lt;= GivenVariance).</p>
<p>Can only be used when PktLag is enabled.</p>
<p>If set lag values will randomly fluctuate between Min and Max. Ignored if PktLag value is set</p>
<p>Set a value to add a minimum delay in milliseconds to incoming packets before they are processed.</p>
<p>The maximum delay in milliseconds to add to incoming packets before they are processed.</p>
<p>The ratio of incoming packets that will be dropped to simulate packet loss</p>
<p>Causes sent packets to have a variable latency that fluctuates from [PktLagMin] to [PktLagMin+PktJitter] Note that this will cause packet loss on the receiving end.</p>
<p>Delays sending packets for a specific number of ticks</p>
<p>Delays processing received packets for a specific number of ticks</p>
<p>reads in settings from the .ini file </p><dl class="section note"><dt>Note</dt><dd>: overwrites all previous settings</dd></dl>
<p>Load a preconfigured emulation profile from the .ini Returns true if the given profile existed</p>
<p>Force new emulation settings and ignore config or cmdline values</p>
<p>Ensure that settings have proper values</p>
<p>Tells if a packet fits the size settings to potentially be dropped</p>
<p>Reads the settings from a string: command line or an exec</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Stream</td><td>the string to read the settings from @Param OptionalQualifier: optional string to prepend to Pkt* settings. E.g, "GameNetDriverPktLoss=50"</td></tr>
  </table>
  </dd>
</dl>
<p>Override the max object count. If 0 use the default system value.</p>
<p>Override the preallocated size of net object lists. If 0 use the default value.</p>
<p>Override the amount to grow every net object list by when they hit the preallocated count. If 0 use the default system value.</p>
<p>Override the number of pre-allocated memory buffers that can hold up to the specified number of objects before they have to grow.</p>
<p>Override the number of pre-allocated objects in FReplicationWriter.</p>
<p>Override the max compressed object count. If 0 use the default system value.</p>
<p>Override the max group count. If 0 use the default system value.</p>

<p class="definition">Definition at line <a class="el" href="NetDriver_8h_source.html#l00453">453</a> of file <a class="el" href="NetDriver_8h_source.html">NetDriver.h</a>.</p>

<p class="reference">References <a class="el" href="RigUnit__AnimNextRunAnimationGraph__v1_8h_source.html#l00024">Category</a>, <a class="el" href="UnrealNames_8h_source.html#l00271">Cmd</a>, <a class="el" href="ObjectMacros_8h_source.html#l00743">GENERATED_BODY</a>, <a class="el" href="Class_8h_source.html#l03937">Name</a>, <a class="el" href="StructuredArchiveFormatter_8h_source.html#l00024">Stream</a>, <a class="el" href="ObjectMacros_8h_source.html#l00723">UPROPERTY</a>, and <a class="el" href="SystemSettings_8h_source.html#l00027">Value</a>.</p>

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="a4e2d462dfccd47fb522a65711bb8090c" name="a4e2d462dfccd47fb522a65711bb8090c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e2d462dfccd47fb522a65711bb8090c">&#9670;&#160;</a></span>CVarNetAllowEncryption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTAutoConsoleVariable.html">TAutoConsoleVariable</a>&lt;<a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&gt; CVarNetAllowEncryption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab11ff6e2f11d151803b3954d03e96ba4" name="ab11ff6e2f11d151803b3954d03e96ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11ff6e2f11d151803b3954d03e96ba4">&#9670;&#160;</a></span>GNetOutBytes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8c7a127091efbdfc5a16939041653e05">uint32</a> GNetOutBytes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bdba4d0ee86d891c1651403ae640f5b" name="a2bdba4d0ee86d891c1651403ae640f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bdba4d0ee86d891c1651403ae640f5b">&#9670;&#160;</a></span>GNumClientConnections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> GNumClientConnections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab9f5d2ef2b989f1e131b626f4b1a0b60" name="ab9f5d2ef2b989f1e131b626f4b1a0b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f5d2ef2b989f1e131b626f4b1a0b60">&#9670;&#160;</a></span>GNumClientUpdateLevelVisibility</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> GNumClientUpdateLevelVisibility</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad754b19225fefedbea0309260eea3383" name="ad754b19225fefedbea0309260eea3383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad754b19225fefedbea0309260eea3383">&#9670;&#160;</a></span>GNumReplicateActorCalls</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> GNumReplicateActorCalls</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5578d92916ca072f72e9c2d0e750f6b0" name="a5578d92916ca072f72e9c2d0e750f6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5578d92916ca072f72e9c2d0e750f6b0">&#9670;&#160;</a></span>GNumSaturatedConnections</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> GNumSaturatedConnections</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b38cd1345758a28185a74c0241c9f96" name="a7b38cd1345758a28185a74c0241c9f96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b38cd1345758a28185a74c0241c9f96">&#9670;&#160;</a></span>GNumSharedSerializationHit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> GNumSharedSerializationHit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae807dc2dfc59b9304cfe351adfac788f" name="ae807dc2dfc59b9304cfe351adfac788f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae807dc2dfc59b9304cfe351adfac788f">&#9670;&#160;</a></span>GNumSharedSerializationMiss</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> GNumSharedSerializationMiss</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acaeef46662f1dccf6e8a0d6984b4ebb6" name="acaeef46662f1dccf6e8a0d6984b4ebb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acaeef46662f1dccf6e8a0d6984b4ebb6">&#9670;&#160;</a></span>GReceiveRPCTimingEnabled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> GReceiveRPCTimingEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9964aa65b82c75951c26a548be9a6730" name="a9964aa65b82c75951c26a548be9a6730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9964aa65b82c75951c26a548be9a6730">&#9670;&#160;</a></span>GReplicateActorTimeSeconds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GReplicateActorTimeSeconds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4e3ff8a280ee64cec7a7a531659b04a" name="ac4e3ff8a280ee64cec7a7a531659b04a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e3ff8a280ee64cec7a7a531659b04a">&#9670;&#160;</a></span>GReplicateActorTimingEnabled</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> GReplicateActorTimingEnabled</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cc76c080a44c39febec9c83a5ce3248" name="a5cc76c080a44c39febec9c83a5ce3248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc76c080a44c39febec9c83a5ce3248">&#9670;&#160;</a></span>GReplicationGatherPrioritizeTimeSeconds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GReplicationGatherPrioritizeTimeSeconds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4da56caded8b454dbf54e0a9224e84c" name="ae4da56caded8b454dbf54e0a9224e84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4da56caded8b454dbf54e0a9224e84c">&#9670;&#160;</a></span>GServerReplicateActorTimeSeconds</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double GServerReplicateActorTimeSeconds</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_7536b172fbd480bfd146a1b1acd6856b.html">Runtime</a></li><li class="navelem"><a href="dir_fdf6aa5c3cf3805bb958134448d60562.html">Engine</a></li><li class="navelem"><a href="dir_0ed647eebe6ffcaa496d3842b7cec6ce.html">Classes</a></li><li class="navelem"><a href="dir_275ee67e3d4a14e20f43a2d02c6b328e.html">Engine</a></li><li class="navelem"><a href="NetDriver_8h.html">NetDriver.h</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Unreal Engine 5.6 C++ API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
