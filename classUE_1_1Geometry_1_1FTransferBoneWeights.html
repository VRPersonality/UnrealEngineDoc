<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unreal Engine 5.6 C++ API: UE::Geometry::FTransferBoneWeights Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Unreal Engine 5.6 C++ API<span id="projectnumber">&#160;5.6.0</span>
   </div>
   <div id="projectbrief">C++ API documentation for Unreal Engine 5.6</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('classUE_1_1Geometry_1_1FTransferBoneWeights.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">UE::Geometry::FTransferBoneWeights Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Transfer bone weights from one mesh (source) to another (target).  
 <a href="#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-types" class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a28c619a9b7bbd0b15abc16ed91da025d" id="r_a28c619a9b7bbd0b15abc16ed91da025d"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025d">ETransferBoneWeightsMethod</a> : uint8 { <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ClosestPointOnSurface</a> = 0
, <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da41564e8398c27397acc70f385d6223c0">InpaintWeights</a> = 1
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-methods" class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afcb6b5247069d499550fb9009028a5b4" id="r_afcb6b5247069d499550fb9009028a5b4"><td class="memItemLeft" align="right" valign="top">DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcb6b5247069d499550fb9009028a5b4">FTransferBoneWeights</a> (const <a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> *InSourceMesh, const <a class="el" href="classFName.html">FName</a> &amp;InSourceProfileName, const <a class="el" href="namespaceUE_1_1Geometry.html#a0ed0559cd6dd4d423419e7d97a071035">FDynamicMeshAABBTree3</a> *<a class="el" href="#a9a350a7fcf979f4b966aa831d5196b0a">SourceBVH</a>=nullptr)</td></tr>
<tr class="memitem:afaff8852d3c30771b4e0f3350ba0c49d" id="r_afaff8852d3c30771b4e0f3350ba0c49d"><td class="memItemLeft" align="right" valign="top">virtual DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afaff8852d3c30771b4e0f3350ba0c49d">~FTransferBoneWeights</a> ()</td></tr>
<tr class="memitem:a460eaa69544a62a5588d11d21a449080" id="r_a460eaa69544a62a5588d11d21a449080"><td class="memItemLeft" align="right" valign="top">virtual DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a460eaa69544a62a5588d11d21a449080">TransferWeightsToMesh</a> (<a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;InOutTargetMesh, const <a class="el" href="classFName.html">FName</a> &amp;InTargetProfileName)</td></tr>
<tr class="memdesc:a460eaa69544a62a5588d11d21a449080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer the bone weights from the source mesh to the given target mesh and store the result in the skin weight <br  />
 attribute with the given profile name.  <br /></td></tr>
<tr class="memitem:afdfa60eb71bc3e9c1c88c56c5fa65ac0" id="r_afdfa60eb71bc3e9c1c88c56c5fa65ac0"><td class="memTemplParams" colspan="2">template&lt;typename BoneIndexType, typename BoneFloatWeightType, typename PosVectorType, typename NormalVectorType = float&gt; </td></tr>
<tr class="memitem:afdfa60eb71bc3e9c1c88c56c5fa65ac0 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdfa60eb71bc3e9c1c88c56c5fa65ac0">TransferWeightsToPoint</a> (<a class="el" href="classTArray.html">TArray</a>&lt; BoneIndexType &gt; &amp;OutBones, <a class="el" href="classTArray.html">TArray</a>&lt; BoneFloatWeightType &gt; &amp;OutWeights, const <a class="el" href="structUE_1_1Math_1_1TVector.html">UE::Math::TVector</a>&lt; PosVectorType &gt; &amp;InPoint, const <a class="el" href="classTMap.html">TMap</a>&lt; <a class="el" href="classFName.html">FName</a>, <a class="el" href="Platform_8h.html#a55934b7aafc849240fa69ea0339c0ab7">uint16</a> &gt; *TargetBoneToIndex=nullptr, const <a class="el" href="structUE_1_1Math_1_1TVector.html">UE::Math::TVector</a>&lt; NormalVectorType &gt; &amp;InNormal=<a class="el" href="structUE_1_1Math_1_1TVector.html">UE::Math::TVector</a>&lt; NormalVectorType &gt;<a class="el" href="MallocBinned2_8h.html#ac0c788e9c284dddee5e077546340455cad7ed4ee1df437474d005188535f74875">::Zero</a>())</td></tr>
<tr class="memdesc:afdfa60eb71bc3e9c1c88c56c5fa65ac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bone weights for a given point using the <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a> algorithm.  <br /></td></tr>
<tr class="memitem:a9676a8c5dd156a066eeef8f7117e0a52" id="r_a9676a8c5dd156a066eeef8f7117e0a52"><td class="memItemLeft" align="right" valign="top">virtual DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9676a8c5dd156a066eeef8f7117e0a52">TransferWeightsToPoint</a> (UE::AnimationCore::FBoneWeights &amp;OutWeights, const <a class="el" href="MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &amp;InPoint, const <a class="el" href="classTMap.html">TMap</a>&lt; <a class="el" href="classFName.html">FName</a>, <a class="el" href="Platform_8h.html#a55934b7aafc849240fa69ea0339c0ab7">uint16</a> &gt; *TargetBoneToIndex=nullptr, const <a class="el" href="MathFwd_8h.html#a4778ceda3f595c7a5f2b088a866a8bf2">FVector3f</a> &amp;InNormal=<a class="el" href="structUE_1_1Math_1_1TVector.html#a2ae137e3abc6e72d0f1f85addc5c537f">FVector3f::Zero</a>())</td></tr>
<tr class="memdesc:a9676a8c5dd156a066eeef8f7117e0a52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the bone weights for a given point using the <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a> algorithm.  <br /></td></tr>
<tr class="memitem:a54523f0089cc45e90b056999c6605a35" id="r_a54523f0089cc45e90b056999c6605a35"><td class="memItemLeft" align="right" valign="top">virtual DYNAMICMESH_API <a class="el" href="namespaceUE_1_1Geometry.html#a14f2b522154f6ccb8ccb0f7abd901174">EOperationValidationResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a54523f0089cc45e90b056999c6605a35">Validate</a> ()</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pub-attribs" class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:a9793d3a9b1b1cf096b1ae3ee1b2c4d0a" id="r_a9793d3a9b1b1cf096b1ae3ee1b2c4d0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9793d3a9b1b1cf096b1ae3ee1b2c4d0a">bIgnoreBoneAttributes</a> = false</td></tr>
<tr class="memdesc:a9793d3a9b1b1cf096b1ae3ee1b2c4d0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Completely ignore the source and target mesh bone attributes when transferring weights from one dynamic mesh to another.  <br /></td></tr>
<tr class="memitem:af75211095f535b8a75efdd7c44671470" id="r_af75211095f535b8a75efdd7c44671470"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af75211095f535b8a75efdd7c44671470">bUseIntrinsicLaplacian</a> = false</td></tr>
<tr class="memdesc:af75211095f535b8a75efdd7c44671470"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, will use the intrinsic Delaunay mesh to construct sparse Cotangent Laplacian matrix.  <br /></td></tr>
<tr class="memitem:af248205e5eb007b728da49c620026229" id="r_af248205e5eb007b728da49c620026229"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af248205e5eb007b728da49c620026229">bUseParallel</a> = true</td></tr>
<tr class="memdesc:af248205e5eb007b728da49c620026229"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable/disable multi-threading.  <br /></td></tr>
<tr class="memitem:ab32757512959b73e74ec27c262e80445" id="r_ab32757512959b73e74ec27c262e80445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTArray.html">TArray</a>&lt; <a class="el" href="SCurveEditor_8h.html#a6a1bb6ed41f44b60e7bd83b0e9945aa7">float</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab32757512959b73e74ec27c262e80445">ForceInpaint</a></td></tr>
<tr class="memdesc:ab32757512959b73e74ec27c262e80445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional mask where if ForceInpaint[VertexID] != 0 we want to force the weights for the vertex to be computed <br  />
 automatically.  <br /></td></tr>
<tr class="memitem:a25fcb44b2c7e82103d10f853eda2b2eb" id="r_a25fcb44b2c7e82103d10f853eda2b2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFName.html">FName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25fcb44b2c7e82103d10f853eda2b2eb">ForceInpaintWeightMapName</a> = NAME_None</td></tr>
<tr class="memdesc:a25fcb44b2c7e82103d10f853eda2b2eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternatively, if the mask is stored as a target mesh weight map attribute, specify its name.  <br /></td></tr>
<tr class="memitem:aa83fa2a2cf8e999b8e2f1f099b2b6a93" id="r_aa83fa2a2cf8e999b8e2f1f099b2b6a93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa83fa2a2cf8e999b8e2f1f099b2b6a93">LayeredMeshSupport</a> = false</td></tr>
<tr class="memdesc:aa83fa2a2cf8e999b8e2f1f099b2b6a93"><td class="mdescLeft">&#160;</td><td class="mdescRight">If true, when the closest point doesn't pass the normal threshold test, will try again with a flipped normal.  <br /></td></tr>
<tr class="memitem:a6f2d315027453ade5c33137a9e9eaf90" id="r_a6f2d315027453ade5c33137a9e9eaf90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTArray.html">TArray</a>&lt; <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6f2d315027453ade5c33137a9e9eaf90">MatchedVertices</a></td></tr>
<tr class="memdesc:a6f2d315027453ade5c33137a9e9eaf90"><td class="mdescLeft">&#160;</td><td class="mdescRight">MatchedVertices[VertexID] is set to true for a target mesh vertex ID with a match found, false otherwise.  <br /></td></tr>
<tr class="memitem:af5bef74808caa630e979e893f9cdfec8" id="r_af5bef74808caa630e979e893f9cdfec8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5bef74808caa630e979e893f9cdfec8">MaxNumInfluences</a> = UE::AnimationCore::MaxInlineBoneWeightCount</td></tr>
<tr class="memdesc:af5bef74808caa630e979e893f9cdfec8"><td class="mdescLeft">&#160;</td><td class="mdescRight">During the transfer, only use this number of influences per vertex.  <br /></td></tr>
<tr class="memitem:a26e25e0c34ff33f7d5ba02f8609f7c8d" id="r_a26e25e0c34ff33f7d5ba02f8609f7c8d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26e25e0c34ff33f7d5ba02f8609f7c8d">NormalThreshold</a> = -1</td></tr>
<tr class="memdesc:a26e25e0c34ff33f7d5ba02f8609f7c8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum angle (in radians) difference between target and source point normals to be considred a match.  <br /></td></tr>
<tr class="memitem:ab3247b7dfdfa013f103d5b175f93d313" id="r_ab3247b7dfdfa013f103d5b175f93d313"><td class="memItemLeft" align="right" valign="top"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3247b7dfdfa013f103d5b175f93d313">NumSmoothingIterations</a> = 0</td></tr>
<tr class="memdesc:ab3247b7dfdfa013f103d5b175f93d313"><td class="mdescLeft">&#160;</td><td class="mdescRight">The number of optional post-processing smoothing iterations applied to the vertices without the match.  <br /></td></tr>
<tr class="memitem:a4d5bd373f9ada11cb5b07e21c775f415" id="r_a4d5bd373f9ada11cb5b07e21c775f415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFProgressCancel.html">FProgressCancel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d5bd373f9ada11cb5b07e21c775f415">Progress</a> = nullptr</td></tr>
<tr class="memdesc:a4d5bd373f9ada11cb5b07e21c775f415"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to be able to cancel the running operation.  <br /></td></tr>
<tr class="memitem:ac717557519b748e5a9bf63030b7d062a" id="r_ac717557519b748e5a9bf63030b7d062a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac717557519b748e5a9bf63030b7d062a">SearchRadius</a> = -1</td></tr>
<tr class="memdesc:ac717557519b748e5a9bf63030b7d062a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Radius for searching the closest point.  <br /></td></tr>
<tr class="memitem:a5d8492c5e77cb92ba9477e50a4f6e258" id="r_a5d8492c5e77cb92ba9477e50a4f6e258"><td class="memItemLeft" align="right" valign="top"><a class="el" href="SCurveEditor_8h.html#a6a1bb6ed41f44b60e7bd83b0e9945aa7">float</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d8492c5e77cb92ba9477e50a4f6e258">SmoothingStrength</a> = 0.0f</td></tr>
<tr class="memdesc:a5d8492c5e77cb92ba9477e50a4f6e258"><td class="mdescLeft">&#160;</td><td class="mdescRight">The strength of each post-processing smoothing iteration.  <br /></td></tr>
<tr class="memitem:aff7e1f34eea30420c765bb958a993900" id="r_aff7e1f34eea30420c765bb958a993900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceUE_1_1Geometry.html#a95f0928e2a866a44db2efe3d685f7874">FTransformSRT3d</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff7e1f34eea30420c765bb958a993900">TargetToWorld</a> = <a class="el" href="classUE_1_1Geometry_1_1TTransformSRT3.html#a0f18a2571930f868aff1ac5a6cb6167a">FTransformSRT3d::Identity</a>()</td></tr>
<tr class="memdesc:aff7e1f34eea30420c765bb958a993900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform applied to the input target mesh or target point before transfer.  <br /></td></tr>
<tr class="memitem:a6069ba76f0b7379b58eddc1273d03667" id="r_a6069ba76f0b7379b58eddc1273d03667"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTArray.html">TArray</a>&lt; <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6069ba76f0b7379b58eddc1273d03667">TargetVerticesSubset</a></td></tr>
<tr class="memdesc:a6069ba76f0b7379b58eddc1273d03667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optional subset of target mesh vertices to transfer weights to.  <br /></td></tr>
<tr class="memitem:aa31f97ec9b15e3ccc46078f0e5963161" id="r_aa31f97ec9b15e3ccc46078f0e5963161"><td class="memItemLeft" align="right" valign="top"><a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025d">ETransferBoneWeightsMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa31f97ec9b15e3ccc46078f0e5963161">TransferMethod</a> = <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a></td></tr>
<tr class="memdesc:aa31f97ec9b15e3ccc46078f0e5963161"><td class="mdescLeft">&#160;</td><td class="mdescRight">The transfer method to compute the bone weights.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-methods" class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a086d5b6551f232e306aa4b6cb9466508" id="r_a086d5b6551f232e306aa4b6cb9466508"><td class="memItemLeft" align="right" valign="top">virtual DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a086d5b6551f232e306aa4b6cb9466508">Cancelled</a> ()</td></tr>
<tr class="memitem:addfccab7dc91c5a609d8f954d856a153" id="r_addfccab7dc91c5a609d8f954d856a153"><td class="memItemLeft" align="right" valign="top">DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addfccab7dc91c5a609d8f954d856a153">FindClosestPointOnSourceSurface</a> (const <a class="el" href="MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &amp;InPoint, const <a class="el" href="namespaceUE_1_1Geometry.html#a95f0928e2a866a44db2efe3d685f7874">FTransformSRT3d</a> &amp;InToWorld, <a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &amp;OutTriID, <a class="el" href="MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &amp;OutBary)</td></tr>
<tr class="memdesc:addfccab7dc91c5a609d8f954d856a153"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the closest point on the surface of the source mesh and return the ID of the triangle containing it and its barycentric coordinates.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-pro-attribs" class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2db21a6c728d148ffe7857a56b4bb8e8" id="r_a2db21a6c728d148ffe7857a56b4bb8e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="namespaceUE_1_1Geometry.html#a0ed0559cd6dd4d423419e7d97a071035">FDynamicMeshAABBTree3</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2db21a6c728d148ffe7857a56b4bb8e8">InternalSourceBVH</a></td></tr>
<tr class="memdesc:a2db21a6c728d148ffe7857a56b4bb8e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the caller doesn't pass BVH for the source mesh then we compute one.  <br /></td></tr>
<tr class="memitem:a1a4bb0fdbdd94d0f44da1b6c016c8d16" id="r_a1a4bb0fdbdd94d0f44da1b6c016c8d16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="classUE_1_1Geometry_1_1FMeshNormals.html">FMeshNormals</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a4bb0fdbdd94d0f44da1b6c016c8d16">InternalSourceMeshNormals</a></td></tr>
<tr class="memdesc:a1a4bb0fdbdd94d0f44da1b6c016c8d16"><td class="mdescLeft">&#160;</td><td class="mdescRight">If the source mesh doesn't have per-vertex normals then compute them.  <br /></td></tr>
<tr class="memitem:a9a350a7fcf979f4b966aa831d5196b0a" id="r_a9a350a7fcf979f4b966aa831d5196b0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespaceUE_1_1Geometry.html#a0ed0559cd6dd4d423419e7d97a071035">FDynamicMeshAABBTree3</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a350a7fcf979f4b966aa831d5196b0a">SourceBVH</a> = nullptr</td></tr>
<tr class="memdesc:a9a350a7fcf979f4b966aa831d5196b0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">The caller can optionally specify the source mesh BVH in case this operator is run on multiple target meshes while the source mesh remains the same.  <br /></td></tr>
<tr class="memitem:a7e2373477b7492f679cf69e108995cd0" id="r_a7e2373477b7492f679cf69e108995cd0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e2373477b7492f679cf69e108995cd0">SourceMesh</a></td></tr>
<tr class="memdesc:a7e2373477b7492f679cf69e108995cd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Source mesh we are transfering weights from.  <br /></td></tr>
<tr class="memitem:a9afd3b8ec54dfadaff9e307ba6282fbd" id="r_a9afd3b8ec54dfadaff9e307ba6282fbd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFName.html">FName</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9afd3b8ec54dfadaff9e307ba6282fbd">SourceProfileName</a></td></tr>
<tr class="memdesc:a9afd3b8ec54dfadaff9e307ba6282fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">The name of the source mesh skinning profile name.  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Transfer bone weights from one mesh (source) to another (target). </p>
<p>Uses the dynamic mesh bone attributes to reindex the bone indices of the transferred weights from the source to the target skeletons. If both meshes have identical bone name attributes, then reindexing is skipped.</p>
<p>During the reindexing, if a weighted bone in the source skeleton is not present in the target skeleton, then the weight is not transferred (skipped), and an error is printed to the console. For best results, the target skeleton should be a superset of all the bones that are indexed by the transferred weights.</p>
<p>Example usage:</p>
<p>FDynamicMesh SourceMesh = ...; // Mesh we transferring weights from. Must have bone attributes. FDynamicMesh TargetMesh = ...; // Mesh we are transferring weights to.</p>
<p><a class="el" href="classUE_1_1Geometry_1_1FTransferBoneWeights.html" title="Transfer bone weights from one mesh (source) to another (target).">FTransferBoneWeights</a> TransferBoneWeights(&amp;SourceMesh, FSkeletalMeshAttributes::DefaultSkinWeightProfileName);</p>
<p>// Optionally, transform the target mesh. This is useful when you want to align the two meshes in world space. TransferBoneWeights.TargetToWorld = ...;</p>
<p>// When transferring weights from a dynamic mesh with bone attributes to a dynamic mesh without bone attributes, // first copy over the bone attributes from the source to the target. if (!TargetMesh.HasAttributes() || !TargetMesh.Attributes()-&gt;HasBones()) { TargetMesh.EnableAttributes(); TargetMesh.Attributes()-&gt;CopyBoneAttributes(*SourceMesh.Attributes()); }</p>
<p>// Set the transfer method. TransferBoneWeights.TransferMethod = <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025d">ETransferBoneWeightsMethod</a>::...;</p>
<p>// if <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a> is used and you simply want to copy weights over from the // closest points then set the radius and normal threshold to -1 (default). TransferBoneWeights.SearchRadius = -1 TransferBoneWeights.NormalThreshold = -1</p>
<p>// if <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da41564e8398c27397acc70f385d6223c0">ETransferBoneWeightsMethod::InpaintWeights</a> is used then additionally set the radius and normal parameters TransferBoneWeights.SearchRadius = ... // Good estimate is to use a small value (0.05) of the bounding box radius TransferBoneWeights.NormalThreshold = ... // 30 degrees (0.52 rad) works well in practice</p>
<p>if (TransferBoneWeights.Validate() == <a class="el" href="namespaceUE_1_1Geometry.html#a14f2b522154f6ccb8ccb0f7abd901174aa60852f204ed8028c1c58808b746d115">EOperationValidationResult::Ok</a>) { TransferBoneWeights.TransferWeightsToMesh(TargetMesh, FSkeletalMeshAttributes::DefaultSkinWeightProfileName); }</p>
<p>// Alternatively if you don't want to use <a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html" title="FDynamicMesh3 is a dynamic triangle mesh class.">FDynamicMesh3</a> to represent your target mesh you can transfer weights to // to each point separately by calling if (TransferBoneWeights.Validate() == <a class="el" href="namespaceUE_1_1Geometry.html#a14f2b522154f6ccb8ccb0f7abd901174aa60852f204ed8028c1c58808b746d115">EOperationValidationResult::Ok</a>) { for each Point: FBoneWeights Weights; TransferBoneWeights.TransferWeightsToPoint(Weights, Point); }</p>
<p>// After the transfer you can check which target mesh vertices had the weight transferred directly from the source mesh // via the <a class="el" href="classUE_1_1Geometry_1_1FTransferBoneWeights.html" title="Transfer bone weights from one mesh (source) to another (target).">FTransferBoneWeights</a>:MatchedVertices array </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00090">90</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>
</div><a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Member Enumeration Documentation</h2>
<a id="a28c619a9b7bbd0b15abc16ed91da025d" name="a28c619a9b7bbd0b15abc16ed91da025d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c619a9b7bbd0b15abc16ed91da025d">&#9670;&#160;</a></span>ETransferBoneWeightsMethod</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025d">UE::Geometry::FTransferBoneWeights::ETransferBoneWeightsMethod</a> : <a class="el" href="Platform_8h.html#a40bc01dd090acd02a79b5dc13e08abe6">uint8</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0" name="a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0"></a>ClosestPointOnSurface&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a28c619a9b7bbd0b15abc16ed91da025da41564e8398c27397acc70f385d6223c0" name="a28c619a9b7bbd0b15abc16ed91da025da41564e8398c27397acc70f385d6223c0"></a>InpaintWeights&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00094">94</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a name="doc-constructors" id="doc-constructors"></a><h2 id="header-doc-constructors" class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="afcb6b5247069d499550fb9009028a5b4" name="afcb6b5247069d499550fb9009028a5b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb6b5247069d499550fb9009028a5b4">&#9670;&#160;</a></span>FTransferBoneWeights()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DYNAMICMESH_API UE::Geometry::FTransferBoneWeights::FTransferBoneWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> *</td>          <td class="paramname"><span class="paramname"><em>InSourceMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFName.html">FName</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InSourceProfileName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceUE_1_1Geometry.html#a0ed0559cd6dd4d423419e7d97a071035">FDynamicMeshAABBTree3</a> *</td>          <td class="paramname"><span class="paramname"><em>SourceBVH</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InSourceMesh</td><td>The mesh we are transferring weights from </td></tr>
    <tr><td class="paramname">InSourceProfileName</td><td>The profile name of the skin weight attribute we are transferring weights from. </td></tr>
    <tr><td class="paramname">SourceBVH</td><td>Optional source mesh BVH. If not provided, one will be computed internally.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that the InSourceMesh has bone attributes, use bIgnoreBoneAttributes flag to ignore the bone attributes and skip re-indexing. </dd></dl>

<p class="reference">References <a class="el" href="TransferBoneWeights_8h_source.html#l00203">SourceBVH</a>, and <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>.</p>

</div>
</div>
<a id="afaff8852d3c30771b4e0f3350ba0c49d" name="afaff8852d3c30771b4e0f3350ba0c49d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaff8852d3c30771b4e0f3350ba0c49d">&#9670;&#160;</a></span>~FTransferBoneWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DYNAMICMESH_API UE::Geometry::FTransferBoneWeights::~FTransferBoneWeights </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Member Function Documentation</h2>
<a id="a086d5b6551f232e306aa4b6cb9466508" name="a086d5b6551f232e306aa4b6cb9466508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a086d5b6551f232e306aa4b6cb9466508">&#9670;&#160;</a></span>Cancelled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::Cancelled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>if true, abort the computation. </dd></dl>

<p class="reference">References <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>.</p>

</div>
</div>
<a id="addfccab7dc91c5a609d8f954d856a153" name="addfccab7dc91c5a609d8f954d856a153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addfccab7dc91c5a609d8f954d856a153">&#9670;&#160;</a></span>FindClosestPointOnSourceSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::FindClosestPointOnSourceSurface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceUE_1_1Geometry.html#a95f0928e2a866a44db2efe3d685f7874">FTransformSRT3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InToWorld</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OutTriID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OutBary</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find the closest point on the surface of the source mesh and return the ID of the triangle containing it and its barycentric coordinates. </p>
<dl class="section return"><dt>Returns</dt><dd>true if point is found, false otherwise </dd></dl>

<p class="reference">References <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>.</p>

</div>
</div>
<a id="a460eaa69544a62a5588d11d21a449080" name="a460eaa69544a62a5588d11d21a449080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a460eaa69544a62a5588d11d21a449080">&#9670;&#160;</a></span>TransferWeightsToMesh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::TransferWeightsToMesh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InOutTargetMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFName.html">FName</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InTargetProfileName</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transfer the bone weights from the source mesh to the given target mesh and store the result in the skin weight <br  />
 attribute with the given profile name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">InOutTargetMesh</td><td>Target mesh we are transfering weights into </td></tr>
    <tr><td class="paramname">InTargetProfileName</td><td>Skin weight profile name we are writing into. If the profile with that name exists, <br  />
 then the data will be overwritten, otherwise a new attribute will be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the algorithm succeeds, false if it failed or was canceled by the user.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Assumes that the InOutTargetMesh has bone attributes, use bIgnoreBoneAttributes flag to ignore the bone attributes and skip re-indexing. </dd></dl>

<p class="reference">References <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>.</p>

</div>
</div>
<a id="afdfa60eb71bc3e9c1c88c56c5fa65ac0" name="afdfa60eb71bc3e9c1c88c56c5fa65ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdfa60eb71bc3e9c1c88c56c5fa65ac0">&#9670;&#160;</a></span>TransferWeightsToPoint() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename BoneIndexType, typename BoneFloatWeightType, typename PosVectorType, typename NormalVectorType = float&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::TransferWeightsToPoint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTArray.html">TArray</a>&lt; BoneIndexType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutBones</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTArray.html">TArray</a>&lt; BoneFloatWeightType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>OutWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUE_1_1Math_1_1TVector.html">UE::Math::TVector</a>&lt; PosVectorType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTMap.html">TMap</a>&lt; <a class="el" href="classFName.html">FName</a>, <a class="el" href="Platform_8h.html#a55934b7aafc849240fa69ea0339c0ab7">uint16</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>TargetBoneToIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structUE_1_1Math_1_1TVector.html">UE::Math::TVector</a>&lt; NormalVectorType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>InNormal</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structUE_1_1Math_1_1TVector.html">UE::Math::TVector</a>&lt;&#160;NormalVectorType&#160;&gt;<a class="el" href="MallocBinned2_8h.html#ac0c788e9c284dddee5e077546340455cad7ed4ee1df437474d005188535f74875">::Zero</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the bone weights for a given point using the <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a> algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutBones</td><td>Array of bone indices. Array size is equal to the number of bone influences. </td></tr>
    <tr><td class="paramname">OutWeights</td><td>Array of bone weights. Array size is equal to the number of bone influences. </td></tr>
    <tr><td class="paramname">InPoint</td><td>Point for which we are computing the bone weight. </td></tr>
    <tr><td class="paramname">TargetBoneToIndex</td><td>Optional map from the bone names to the bone indices of the target skeleton. If null, the bone indices of the skinning weights will not be re-indexed after the transfer. </td></tr>
    <tr><td class="paramname">InNormal</td><td>Normal at the input point. Should be set if NormalThreshold &gt;= 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the algorithm succeeds, false if it failed to find the matching point or was canceled by the user.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Add specialization in the source file for template types you want to use. Currently supporting int for BoneIndexType and float for BoneFloatWeightType, PosVectorType, NormalVectorType </dd></dl>

<p class="reference">References <a class="el" href="Vector_8h_source.html#l00112">UE::Math::TVector&lt; T &gt;::Zero()</a>.</p>

</div>
</div>
<a id="a9676a8c5dd156a066eeef8f7117e0a52" name="a9676a8c5dd156a066eeef8f7117e0a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9676a8c5dd156a066eeef8f7117e0a52">&#9670;&#160;</a></span>TransferWeightsToPoint() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DYNAMICMESH_API <a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::TransferWeightsToPoint </td>
          <td>(</td>
          <td class="paramtype">UE::AnimationCore::FBoneWeights &amp;</td>          <td class="paramname"><span class="paramname"><em>OutWeights</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InPoint</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTMap.html">TMap</a>&lt; <a class="el" href="classFName.html">FName</a>, <a class="el" href="Platform_8h.html#a55934b7aafc849240fa69ea0339c0ab7">uint16</a> &gt; *</td>          <td class="paramname"><span class="paramname"><em>TargetBoneToIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="MathFwd_8h.html#a4778ceda3f595c7a5f2b088a866a8bf2">FVector3f</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>InNormal</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="structUE_1_1Math_1_1TVector.html#a2ae137e3abc6e72d0f1f85addc5c537f">FVector3f::Zero</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compute the bone weights for a given point using the <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a> algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">OutWeights</td><td>Bone weight computed for the input transformed point. </td></tr>
    <tr><td class="paramname">InPoint</td><td>Point for which we are computing the bone weight. </td></tr>
    <tr><td class="paramname">TargetBoneToIndex</td><td>Optional map from the bone names to the bone indices of the target skeleton. If null, the bone indices of the skinning weights will not be re-indexed after the transfer. </td></tr>
    <tr><td class="paramname">InNormal</td><td>Normal at the input point. Should be set if NormalThreshold &gt;= 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the algorithm succeeds, false if it failed to find the matching point or was canceled by the user. </dd></dl>

<p class="reference">References <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>, and <a class="el" href="Vector_8h_source.html#l00112">UE::Math::TVector&lt; float &gt;::Zero()</a>.</p>

</div>
</div>
<a id="a54523f0089cc45e90b056999c6605a35" name="a54523f0089cc45e90b056999c6605a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54523f0089cc45e90b056999c6605a35">&#9670;&#160;</a></span>Validate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual DYNAMICMESH_API <a class="el" href="namespaceUE_1_1Geometry.html#a14f2b522154f6ccb8ccb0f7abd901174">EOperationValidationResult</a> UE::Geometry::FTransferBoneWeights::Validate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="namespaceUE_1_1Geometry.html#a14f2b522154f6ccb8ccb0f7abd901174aa60852f204ed8028c1c58808b746d115">EOperationValidationResult::Ok</a> if we can apply operation, or error code if we cannot. </dd></dl>

<p class="reference">References <a class="el" href="AnimNextConfig_8h_source.html#l00007">UE_API</a>.</p>

</div>
</div>
<a name="doc-variable-members" id="doc-variable-members"></a><h2 id="header-doc-variable-members" class="groupheader">Field Documentation</h2>
<a id="a9793d3a9b1b1cf096b1ae3ee1b2c4d0a" name="a9793d3a9b1b1cf096b1ae3ee1b2c4d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9793d3a9b1b1cf096b1ae3ee1b2c4d0a">&#9670;&#160;</a></span>bIgnoreBoneAttributes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::bIgnoreBoneAttributes = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Completely ignore the source and target mesh bone attributes when transferring weights from one dynamic mesh to another. </p>
<p>This skips re-indexing and simply copies skin weights over. Use with caution. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00126">126</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="af75211095f535b8a75efdd7c44671470" name="af75211095f535b8a75efdd7c44671470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75211095f535b8a75efdd7c44671470">&#9670;&#160;</a></span>bUseIntrinsicLaplacian</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::bUseIntrinsicLaplacian = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, will use the intrinsic Delaunay mesh to construct sparse Cotangent Laplacian matrix. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00155">155</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="af248205e5eb007b728da49c620026229" name="af248205e5eb007b728da49c620026229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af248205e5eb007b728da49c620026229">&#9670;&#160;</a></span>bUseParallel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::bUseParallel = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable/disable multi-threading. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00114">114</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="ab32757512959b73e74ec27c262e80445" name="ab32757512959b73e74ec27c262e80445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32757512959b73e74ec27c262e80445">&#9670;&#160;</a></span>ForceInpaint</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTArray.html">TArray</a>&lt;<a class="el" href="SCurveEditor_8h.html#a6a1bb6ed41f44b60e7bd83b0e9945aa7">float</a>&gt; UE::Geometry::FTransferBoneWeights::ForceInpaint</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional mask where if ForceInpaint[VertexID] != 0 we want to force the weights for the vertex to be computed <br  />
 automatically. </p>
<dl class="section note"><dt>Note</dt><dd>Only used when TransferMethod == <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da41564e8398c27397acc70f385d6223c0">ETransferBoneWeightsMethod::InpaintWeights</a>. The size must be equal to the InTargetMesh.MaxVertexID(), otherwise the mask is ignored. </dd></dl>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00170">170</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a25fcb44b2c7e82103d10f853eda2b2eb" name="a25fcb44b2c7e82103d10f853eda2b2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fcb44b2c7e82103d10f853eda2b2eb">&#9670;&#160;</a></span>ForceInpaintWeightMapName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFName.html">FName</a> UE::Geometry::FTransferBoneWeights::ForceInpaintWeightMapName = NAME_None</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alternatively, if the mask is stored as a target mesh weight map attribute, specify its name. </p>
<p>Will be ignored if the ForceInpaint array is not empty and valid. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00176">176</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a2db21a6c728d148ffe7857a56b4bb8e8" name="a2db21a6c728d148ffe7857a56b4bb8e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db21a6c728d148ffe7857a56b4bb8e8">&#9670;&#160;</a></span>InternalSourceBVH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTUniquePtr.html">TUniquePtr</a>&lt;<a class="el" href="namespaceUE_1_1Geometry.html#a0ed0559cd6dd4d423419e7d97a071035">FDynamicMeshAABBTree3</a>&gt; UE::Geometry::FTransferBoneWeights::InternalSourceBVH</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the caller doesn't pass BVH for the source mesh then we compute one. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00206">206</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a1a4bb0fdbdd94d0f44da1b6c016c8d16" name="a1a4bb0fdbdd94d0f44da1b6c016c8d16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4bb0fdbdd94d0f44da1b6c016c8d16">&#9670;&#160;</a></span>InternalSourceMeshNormals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTUniquePtr.html">TUniquePtr</a>&lt;<a class="el" href="classUE_1_1Geometry_1_1FMeshNormals.html">FMeshNormals</a>&gt; UE::Geometry::FTransferBoneWeights::InternalSourceMeshNormals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If the source mesh doesn't have per-vertex normals then compute them. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00209">209</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="aa83fa2a2cf8e999b8e2f1f099b2b6a93" name="aa83fa2a2cf8e999b8e2f1f099b2b6a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa83fa2a2cf8e999b8e2f1f099b2b6a93">&#9670;&#160;</a></span>LayeredMeshSupport</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> UE::Geometry::FTransferBoneWeights::LayeredMeshSupport = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If true, when the closest point doesn't pass the normal threshold test, will try again with a flipped normal. </p>
<p>This helps with layered meshes where the "inner" and "outer" layers are close to each other but whose normals are pointing in the opposite directions. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00146">146</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a6f2d315027453ade5c33137a9e9eaf90" name="a6f2d315027453ade5c33137a9e9eaf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f2d315027453ade5c33137a9e9eaf90">&#9670;&#160;</a></span>MatchedVertices</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTArray.html">TArray</a>&lt;<a class="el" href="RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a>&gt; UE::Geometry::FTransferBoneWeights::MatchedVertices</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>MatchedVertices[VertexID] is set to true for a target mesh vertex ID with a match found, false otherwise. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00189">189</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="af5bef74808caa630e979e893f9cdfec8" name="af5bef74808caa630e979e893f9cdfec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5bef74808caa630e979e893f9cdfec8">&#9670;&#160;</a></span>MaxNumInfluences</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> UE::Geometry::FTransferBoneWeights::MaxNumInfluences = UE::AnimationCore::MaxInlineBoneWeightCount</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>During the transfer, only use this number of influences per vertex. </p>
<p>Prune the excess with the smallest influences and re-normalize. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00161">161</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a26e25e0c34ff33f7d5ba02f8609f7c8d" name="a26e25e0c34ff33f7d5ba02f8609f7c8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e25e0c34ff33f7d5ba02f8609f7c8d">&#9670;&#160;</a></span>NormalThreshold</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double UE::Geometry::FTransferBoneWeights::NormalThreshold = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum angle (in radians) difference between target and source point normals to be considred a match. </p>
<p>If negative, normals are ignored. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00139">139</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="ab3247b7dfdfa013f103d5b175f93d313" name="ab3247b7dfdfa013f103d5b175f93d313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3247b7dfdfa013f103d5b175f93d313">&#9670;&#160;</a></span>NumSmoothingIterations</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> UE::Geometry::FTransferBoneWeights::NumSmoothingIterations = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The number of optional post-processing smoothing iterations applied to the vertices without the match. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00149">149</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a4d5bd373f9ada11cb5b07e21c775f415" name="a4d5bd373f9ada11cb5b07e21c775f415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d5bd373f9ada11cb5b07e21c775f415">&#9670;&#160;</a></span>Progress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFProgressCancel.html">FProgressCancel</a>* UE::Geometry::FTransferBoneWeights::Progress = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set this to be able to cancel the running operation. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00111">111</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="ac717557519b748e5a9bf63030b7d062a" name="ac717557519b748e5a9bf63030b7d062a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac717557519b748e5a9bf63030b7d062a">&#9670;&#160;</a></span>SearchRadius</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double UE::Geometry::FTransferBoneWeights::SearchRadius = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Radius for searching the closest point. </p>
<p>If negative, all points are considered. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00133">133</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a5d8492c5e77cb92ba9477e50a4f6e258" name="a5d8492c5e77cb92ba9477e50a4f6e258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8492c5e77cb92ba9477e50a4f6e258">&#9670;&#160;</a></span>SmoothingStrength</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="SCurveEditor_8h.html#a6a1bb6ed41f44b60e7bd83b0e9945aa7">float</a> UE::Geometry::FTransferBoneWeights::SmoothingStrength = 0.0f</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The strength of each post-processing smoothing iteration. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00152">152</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a9a350a7fcf979f4b966aa831d5196b0a" name="a9a350a7fcf979f4b966aa831d5196b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a350a7fcf979f4b966aa831d5196b0a">&#9670;&#160;</a></span>SourceBVH</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespaceUE_1_1Geometry.html#a0ed0559cd6dd4d423419e7d97a071035">FDynamicMeshAABBTree3</a>* UE::Geometry::FTransferBoneWeights::SourceBVH = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The caller can optionally specify the source mesh BVH in case this operator is run on multiple target meshes while the source mesh remains the same. </p>
<p>Otherwise BVH tree will be computed. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00203">203</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

<p class="reference">Referenced by <a class="el" href="#afcb6b5247069d499550fb9009028a5b4">FTransferBoneWeights()</a>.</p>

</div>
</div>
<a id="a7e2373477b7492f679cf69e108995cd0" name="a7e2373477b7492f679cf69e108995cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2373477b7492f679cf69e108995cd0">&#9670;&#160;</a></span>SourceMesh</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a>* UE::Geometry::FTransferBoneWeights::SourceMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Source mesh we are transfering weights from. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00194">194</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a9afd3b8ec54dfadaff9e307ba6282fbd" name="a9afd3b8ec54dfadaff9e307ba6282fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afd3b8ec54dfadaff9e307ba6282fbd">&#9670;&#160;</a></span>SourceProfileName</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFName.html">FName</a> UE::Geometry::FTransferBoneWeights::SourceProfileName</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The name of the source mesh skinning profile name. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00197">197</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="aff7e1f34eea30420c765bb958a993900" name="aff7e1f34eea30420c765bb958a993900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff7e1f34eea30420c765bb958a993900">&#9670;&#160;</a></span>TargetToWorld</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceUE_1_1Geometry.html#a95f0928e2a866a44db2efe3d685f7874">FTransformSRT3d</a> UE::Geometry::FTransferBoneWeights::TargetToWorld = <a class="el" href="classUE_1_1Geometry_1_1TTransformSRT3.html#a0f18a2571930f868aff1ac5a6cb6167a">FTransformSRT3d::Identity</a>()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform applied to the input target mesh or target point before transfer. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00120">120</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="a6069ba76f0b7379b58eddc1273d03667" name="a6069ba76f0b7379b58eddc1273d03667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6069ba76f0b7379b58eddc1273d03667">&#9670;&#160;</a></span>TargetVerticesSubset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTArray.html">TArray</a>&lt;<a class="el" href="Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&gt; UE::Geometry::FTransferBoneWeights::TargetVerticesSubset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optional subset of target mesh vertices to transfer weights to. </p>
<p>If left empty, skin weights will be transferred to all target mesh vertices. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00182">182</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<a id="aa31f97ec9b15e3ccc46078f0e5963161" name="aa31f97ec9b15e3ccc46078f0e5963161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa31f97ec9b15e3ccc46078f0e5963161">&#9670;&#160;</a></span>TransferMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025d">ETransferBoneWeightsMethod</a> UE::Geometry::FTransferBoneWeights::TransferMethod = <a class="el" href="#a28c619a9b7bbd0b15abc16ed91da025da87aa674a9770ee15812ac82209a97bd0">ETransferBoneWeightsMethod::ClosestPointOnSurface</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The transfer method to compute the bone weights. </p>

<p class="definition">Definition at line <a class="el" href="TransferBoneWeights_8h_source.html#l00117">117</a> of file <a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>S:/Development/U_E/UE_5.6/Engine/Plugins/Runtime/GeometryProcessing/Source/DynamicMesh/Public/Operations/<a class="el" href="TransferBoneWeights_8h_source.html">TransferBoneWeights.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="namespaceUE.html">UE</a></li><li class="navelem"><a href="namespaceUE_1_1Geometry.html">Geometry</a></li><li class="navelem"><a href="classUE_1_1Geometry_1_1FTransferBoneWeights.html">FTransferBoneWeights</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Unreal Engine 5.6 C++ API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
