<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Unreal Engine 5.6 C++ API: UE::MeshDeformation Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../custom.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only-darkmode-toggle.css" rel="stylesheet" type="text/css"/>
<link href="../../custom-alternative.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Unreal Engine 5.6 C++ API<span id="projectnumber">&#160;5.6.0</span>
   </div>
   <div id="projectbrief">C++ API documentation for Unreal Engine 5.6</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('da/df1/namespaceUE_1_1MeshDeformation.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">UE::MeshDeformation Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:CotanTriangleData" id="r_CotanTriangleData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/dc0/classUE_1_1MeshDeformation_1_1CotanTriangleData.html">CotanTriangleData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The per-triangle data used in constructing the cotangent weighted laplacian.  <a href="../../d8/dc0/classUE_1_1MeshDeformation_1_1CotanTriangleData.html#details">More...</a><br /></td></tr>
<tr class="memitem:MeanValueTriangleData" id="r_MeanValueTriangleData"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/db2/classUE_1_1MeshDeformation_1_1MeanValueTriangleData.html">MeanValueTriangleData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The per-triangle data used in constructing the mean-value weighted laplacian.  <a href="../../d3/db2/classUE_1_1MeshDeformation_1_1MeanValueTriangleData.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9a874fe9f39817ee5f88f3791f4f490f" id="r_a9a874fe9f39817ee5f88f3791f4f490f"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490f">ECotangentAreaMode</a> { <a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55">NoArea</a> = 0
, <a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490fa5415a95f4b4adf55f7ada3350758833f">VoronoiArea</a> = 1
 }</td></tr>
<tr class="memitem:a445122076708a599dcff3ea2073d9105" id="r_a445122076708a599dcff3ea2073d9105"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a445122076708a599dcff3ea2073d9105">ECotangentWeightMode</a> { <a class="el" href="#a445122076708a599dcff3ea2073d9105a7a1920d61156abc05a60135aefe8bc67">Default</a> = 0
, <a class="el" href="#a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb">ClampedMagnitude</a> = 1
, <a class="el" href="#a445122076708a599dcff3ea2073d9105a77a03c3f949858edd6d7727ce3f3d876">TriangleArea</a> = 2
 }</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a32fd03ba183b8fb7890b0df54b9a4211" id="r_a32fd03ba183b8fb7890b0df54b9a4211"><td class="memTemplParams" colspan="2">template&lt;typename MeshT&gt; </td></tr>
<tr class="memitem:a32fd03ba183b8fb7890b0df54b9a4211 template"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a32fd03ba183b8fb7890b0df54b9a4211">ComputeNumMatrixElements</a> (const MeshT &amp;DynamicMesh, const <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &gt; &amp;ToVtxId)</td></tr>
<tr class="memitem:a4812c7ce23c805e07abf7e769e99d6fe" id="r_a4812c7ce23c805e07abf7e769e99d6fe"><td class="memItemLeft" align="right" valign="top">void DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4812c7ce23c805e07abf7e769e99d6fe">ComputeSmoothing_BiHarmonic</a> (const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a> WeightingScheme, const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;OriginalMesh, const double <a class="el" href="../../d5/d79/UnitConversion_8h.html#afece06a778c21908864f232441e2925aa44877c6aa8e93fa5a91c9361211464fb">Speed</a>, const double <a class="el" href="../../db/d95/MovieSceneSection_8h.html#aa5aef7d31d756c97d012e9120ceef787a8c489d0946f66d17d73f26366a4bf620">Weight</a>, const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> NumIterations, <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;PositionArray, <a class="el" href="../../de/d99/classFProgressCancel.html">FProgressCancel</a> *Progress=nullptr)</td></tr>
<tr class="memdesc:a4812c7ce23c805e07abf7e769e99d6fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Note: for discussion of implicit / explicit integration of diffusion and biharmonic equations see "Implicit Fairing of Irregular Meshes using Diffusion and Curvature Flow" - M Desbrun 99.  <br /></td></tr>
<tr class="memitem:a2db09148a561437e685887afd3853ddc" id="r_a2db09148a561437e685887afd3853ddc"><td class="memItemLeft" align="right" valign="top">void DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2db09148a561437e685887afd3853ddc">ComputeSmoothing_Diffusion</a> (const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a> WeightScheme, const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;OriginalMesh, <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bForwardEuler, const double <a class="el" href="../../d5/d79/UnitConversion_8h.html#afece06a778c21908864f232441e2925aa44877c6aa8e93fa5a91c9361211464fb">Speed</a>, double <a class="el" href="../../db/d95/MovieSceneSection_8h.html#aa5aef7d31d756c97d012e9120ceef787a8c489d0946f66d17d73f26366a4bf620">Weight</a>, const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> NumIterations, <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;PositionArray, <a class="el" href="../../de/d99/classFProgressCancel.html">FProgressCancel</a> *Progress=nullptr)</td></tr>
<tr class="memdesc:a2db09148a561437e685887afd3853ddc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is equivalent to forward or backward Euler time steps of the diffusion equation.  <br /></td></tr>
<tr class="memitem:afb592ec10a02935bf6842a81ae5f9799" id="r_afb592ec10a02935bf6842a81ae5f9799"><td class="memItemLeft" align="right" valign="top">void DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb592ec10a02935bf6842a81ae5f9799">ComputeSmoothing_Forward</a> (<a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bUniformWeightScheme, <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bSmoothBoundary, const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;OriginalMesh, <a class="el" href="../../de/d23/classTFunctionRef.html">TFunctionRef</a>&lt; double(int VID, <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bBoundary)&gt; GetSmoothingAlpha, const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> NumIterations, <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;PositionArray, class <a class="el" href="../../de/d99/classFProgressCancel.html">FProgressCancel</a> *Progress=nullptr)</td></tr>
<tr class="memdesc:afb592ec10a02935bf6842a81ae5f9799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple iterative smoothing with an optional weight map Each iteration Lerps towards the weighted neighbor centroid by the GetSmoothingAlpha amount.  <br /></td></tr>
<tr class="memitem:ac30f576ea7bf67c2a0f35b3596ddb055" id="r_ac30f576ea7bf67c2a0f35b3596ddb055"><td class="memItemLeft" align="right" valign="top">void DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac30f576ea7bf67c2a0f35b3596ddb055">ComputeSmoothing_ImplicitBiHarmonicPCG</a> (const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a> WeightScheme, const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;OriginalMesh, const double <a class="el" href="../../d5/d79/UnitConversion_8h.html#afece06a778c21908864f232441e2925aa44877c6aa8e93fa5a91c9361211464fb">Speed</a>, const double <a class="el" href="../../db/d95/MovieSceneSection_8h.html#aa5aef7d31d756c97d012e9120ceef787a8c489d0946f66d17d73f26366a4bf620">Weight</a>, const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> MaxIterations, <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;PositionArray)</td></tr>
<tr class="memitem:af7b567308bbbd1c53a64485d79191860" id="r_af7b567308bbbd1c53a64485d79191860"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../de/da0/classUE_1_1Solvers_1_1IConstrainedMeshSolver.html">UE::Solvers::IConstrainedMeshSolver</a> &gt; DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7b567308bbbd1c53a64485d79191860">ConstructConstrainedMeshDeformer</a> (const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a> WeightScheme, const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh)</td></tr>
<tr class="memdesc:af7b567308bbbd1c53a64485d79191860"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the linear system for p_vec.  <br /></td></tr>
<tr class="memitem:a5cf07468a64a284a2edbd8dbc4139a36" id="r_a5cf07468a64a284a2edbd8dbc4139a36"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../de/da0/classUE_1_1Solvers_1_1IConstrainedMeshSolver.html">UE::Solvers::IConstrainedMeshSolver</a> &gt; DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5cf07468a64a284a2edbd8dbc4139a36">ConstructConstrainedMeshSmoother</a> (const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a> WeightScheme, const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh)</td></tr>
<tr class="memdesc:a5cf07468a64a284a2edbd8dbc4139a36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the linear system for p_vec.  <br /></td></tr>
<tr class="memitem:abb5ba9e1b374edf6d77271067c602718" id="r_abb5ba9e1b374edf6d77271067c602718"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:abb5ba9e1b374edf6d77271067c602718 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb5ba9e1b374edf6d77271067c602718">ConstructCotangentLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;AreaMatrix, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary)</td></tr>
<tr class="memdesc:abb5ba9e1b374edf6d77271067c602718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation using a cotangent-weighted Laplacian.  <br /></td></tr>
<tr class="memitem:aaf997123f9e9bc9c6853c6ba0330b986" id="r_aaf997123f9e9bc9c6853c6ba0330b986"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:aaf997123f9e9bc9c6853c6ba0330b986 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaf997123f9e9bc9c6853c6ba0330b986">ConstructCotangentLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary, const <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bClampWeights)</td></tr>
<tr class="memdesc:aaf997123f9e9bc9c6853c6ba0330b986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation using a pre-multiplied cotangent-weighted Laplacian.  <br /></td></tr>
<tr class="memitem:aa5a170f0f1f1086b297d466bfe1f8ca1" id="r_aa5a170f0f1f1086b297d466bfe1f8ca1"><td class="memItemLeft" align="right" valign="top">void DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5a170f0f1f1086b297d466bfe1f8ca1">ConstructEdgeCotanWeightsDataArray</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;<a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#a7dee17fef2638b45c18acdf7707bd36b">Mesh</a>, <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; double &gt; &amp;EdgeWeightsDataArray, double ClampMin=-1.e5, double ClampMax=1.e5)</td></tr>
<tr class="memitem:ae792924418f806431fc29afa28c3716f" id="r_ae792924418f806431fc29afa28c3716f"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:ae792924418f806431fc29afa28c3716f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae792924418f806431fc29afa28c3716f">ConstructFullCotangentLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianMatrix, <a class="el" href="#a445122076708a599dcff3ea2073d9105">ECotangentWeightMode</a> WeightMode=<a class="el" href="#a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb">ECotangentWeightMode::ClampedMagnitude</a>, <a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490f">ECotangentAreaMode</a> AreaMode=<a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55">ECotangentAreaMode::NoArea</a>)</td></tr>
<tr class="memdesc:ae792924418f806431fc29afa28c3716f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct sparse Cotangent Laplacian matrix.  <br /></td></tr>
<tr class="memitem:a65dc6e343bd575c6673bf8c0b482ffde" id="r_a65dc6e343bd575c6673bf8c0b482ffde"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:a65dc6e343bd575c6673bf8c0b482ffde template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65dc6e343bd575c6673bf8c0b482ffde">ConstructFullIDTCotangentLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;<a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#a7dee17fef2638b45c18acdf7707bd36b">Mesh</a>, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianMatrix, <a class="el" href="#a445122076708a599dcff3ea2073d9105">ECotangentWeightMode</a> WeightMode=<a class="el" href="#a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb">ECotangentWeightMode::ClampedMagnitude</a>, <a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490f">ECotangentAreaMode</a> AreaMode=<a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55">ECotangentAreaMode::NoArea</a>)</td></tr>
<tr class="memdesc:a65dc6e343bd575c6673bf8c0b482ffde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use intrinsic Delaunay mesh to construct sparse Cotangent Laplacian matrix.  <br /></td></tr>
<tr class="memitem:ad7e9fddf45aa4a169e3cec1788bd8eee" id="r_ad7e9fddf45aa4a169e3cec1788bd8eee"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:ad7e9fddf45aa4a169e3cec1788bd8eee template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7e9fddf45aa4a169e3cec1788bd8eee">ConstructIDTCotangentLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary, const <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bClampWeights)</td></tr>
<tr class="memdesc:ad7e9fddf45aa4a169e3cec1788bd8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation using a pre-multiplied cotangent-weighted Laplacian, using an intrinsic Delaunay mesh internally NB: there is no reason to expect this to be a symmetric matrix.  <br /></td></tr>
<tr class="memitem:a8cfb166d2dee288b2c69e7a3942f1f16" id="r_a8cfb166d2dee288b2c69e7a3942f1f16"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:a8cfb166d2dee288b2c69e7a3942f1f16 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cfb166d2dee288b2c69e7a3942f1f16">ConstructMeanValueWeightLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary)</td></tr>
<tr class="memdesc:a8cfb166d2dee288b2c69e7a3942f1f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation using a meanvalue-weighted Laplacian.  <br /></td></tr>
<tr class="memitem:aba3b027c57ad1b96ce0040240913f154" id="r_aba3b027c57ad1b96ce0040240913f154"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../d9/deb/classUE_1_1Solvers_1_1IConstrainedMeshUVSolver.html">UE::Solvers::IConstrainedMeshUVSolver</a> &gt; DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba3b027c57ad1b96ce0040240913f154">ConstructNaturalConformalParamSolver</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh)</td></tr>
<tr class="memdesc:aba3b027c57ad1b96ce0040240913f154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create solver for the Least Squares Conformal UV Parameterization for this mesh.  <br /></td></tr>
<tr class="memitem:a5811e816dcc6ade5f779f52079d1527d" id="r_a5811e816dcc6ade5f779f52079d1527d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../df/d0b/classUE_1_1Solvers_1_1IConstrainedLaplacianMeshSolver.html">UE::Solvers::IConstrainedLaplacianMeshSolver</a> &gt; DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5811e816dcc6ade5f779f52079d1527d">ConstructSoftMeshDeformer</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh)</td></tr>
<tr class="memdesc:a5811e816dcc6ade5f779f52079d1527d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a Mesh Deformer object for the given mesh that uses Biharmonic Laplacian Mesh Deformation to solve for the deformed vertex positions.  <br /></td></tr>
<tr class="memitem:ab015c49845a42ccdf25b6f208a562e57" id="r_ab015c49845a42ccdf25b6f208a562e57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../d9/deb/classUE_1_1Solvers_1_1IConstrainedMeshUVSolver.html">UE::Solvers::IConstrainedMeshUVSolver</a> &gt; DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab015c49845a42ccdf25b6f208a562e57">ConstructSpectralConformalParamSolver</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bPreserveIrregularity)</td></tr>
<tr class="memdesc:ab015c49845a42ccdf25b6f208a562e57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create solver for the Spectral Conformal UV Parameterization for this mesh.  <br /></td></tr>
<tr class="memitem:ad8780349428dfee6b9e4c2b338ee5ffc" id="r_ad8780349428dfee6b9e4c2b338ee5ffc"><td class="memTemplParams" colspan="2">template&lt;typename TriangleDataType&gt; </td></tr>
<tr class="memitem:ad8780349428dfee6b9e4c2b338ee5ffc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8780349428dfee6b9e4c2b338ee5ffc">ConstructTriangleDataArray</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../db/dc2/classUE_1_1Geometry_1_1FTriangleLinearization.html">FTriangleLinearization</a> &amp;TriangleLinearization, <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; TriangleDataType &gt; &amp;TriangleDataArray)</td></tr>
<tr class="memdesc:ad8780349428dfee6b9e4c2b338ee5ffc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return and array in triangle order that holds the per-triangle derived data needed.  <br /></td></tr>
<tr class="memitem:a1e94c672286fff67d41a1398142f4827" id="r_a1e94c672286fff67d41a1398142f4827"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:a1e94c672286fff67d41a1398142f4827 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e94c672286fff67d41a1398142f4827">ConstructUmbrellaLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary)</td></tr>
<tr class="memdesc:a1e94c672286fff67d41a1398142f4827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation of an umbrella weighted Laplacian.  <br /></td></tr>
<tr class="memitem:a16f5e009a2ea06db28ac0ba7bd34d87a" id="r_a16f5e009a2ea06db28ac0ba7bd34d87a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../de/da0/classUE_1_1Solvers_1_1IConstrainedMeshSolver.html">UE::Solvers::IConstrainedMeshSolver</a> &gt; DYNAMICMESH_API&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16f5e009a2ea06db28ac0ba7bd34d87a">ConstructUniformConstrainedMeshDeformer</a> (const <a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#aeb80441b3597cadec9dd41631706afe3">FDynamicGraph3d</a> &amp;Graph)</td></tr>
<tr class="memdesc:a16f5e009a2ea06db28ac0ba7bd34d87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a mesh with only edges and vertices.  <br /></td></tr>
<tr class="memitem:a694b1bb9f614a1046908e13b7315c5f7" id="r_a694b1bb9f614a1046908e13b7315c5f7"><td class="memTemplParams" colspan="2">template&lt;typename RealType, typename MeshType&gt; </td></tr>
<tr class="memitem:a694b1bb9f614a1046908e13b7315c5f7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a694b1bb9f614a1046908e13b7315c5f7">ConstructUniformLaplacian</a> (const MeshType &amp;<a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#a7dee17fef2638b45c18acdf7707bd36b">Mesh</a>, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary)</td></tr>
<tr class="memdesc:a694b1bb9f614a1046908e13b7315c5f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation of a uniform weighted Laplacian.  <br /></td></tr>
<tr class="memitem:a7f0420ccd091c996034cc49e0c4c8ee2" id="r_a7f0420ccd091c996034cc49e0c4c8ee2"><td class="memTemplParams" colspan="2">template&lt;typename RealType&gt; </td></tr>
<tr class="memitem:a7f0420ccd091c996034cc49e0c4c8ee2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f0420ccd091c996034cc49e0c4c8ee2">ConstructValenceWeightedLaplacian</a> (const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;DynamicMesh, const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;VertexMap, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianInterior, <a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;LaplacianBoundary)</td></tr>
<tr class="memdesc:a7f0420ccd091c996034cc49e0c4c8ee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a sparse matrix representation of a valence-weighted Laplacian.  <br /></td></tr>
</table>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a9a874fe9f39817ee5f88f3791f4f490f" name="a9a874fe9f39817ee5f88f3791f4f490f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a874fe9f39817ee5f88f3791f4f490f">&#9670;&#160;</a></span>ECotangentAreaMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490f">UE::MeshDeformation::ECotangentAreaMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55" name="a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55"></a>NoArea&#160;</td><td class="fielddoc"><p>uniform-weighted cotangents </p>
</td></tr>
<tr><td class="fieldname"><a id="a9a874fe9f39817ee5f88f3791f4f490fa5415a95f4b4adf55f7ada3350758833f" name="a9a874fe9f39817ee5f88f3791f4f490fa5415a95f4b4adf55f7ada3350758833f"></a>VoronoiArea&#160;</td><td class="fielddoc"><p>weight each vertex/row by 1/voronoi_area </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00207">207</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

</div>
</div>
<a id="a445122076708a599dcff3ea2073d9105" name="a445122076708a599dcff3ea2073d9105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a445122076708a599dcff3ea2073d9105">&#9670;&#160;</a></span>ECotangentWeightMode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum class <a class="el" href="#a445122076708a599dcff3ea2073d9105">UE::MeshDeformation::ECotangentWeightMode</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel strong">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a445122076708a599dcff3ea2073d9105a7a1920d61156abc05a60135aefe8bc67" name="a445122076708a599dcff3ea2073d9105a7a1920d61156abc05a60135aefe8bc67"></a>Default&#160;</td><td class="fielddoc"><p>Standard cotangent weights. </p>
</td></tr>
<tr><td class="fieldname"><a id="a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb" name="a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb"></a>ClampedMagnitude&#160;</td><td class="fielddoc"><p>Magnitude of matrix entries clamped to [-1e5,1e5], scaled by area weight. </p>
</td></tr>
<tr><td class="fieldname"><a id="a445122076708a599dcff3ea2073d9105a77a03c3f949858edd6d7727ce3f3d876" name="a445122076708a599dcff3ea2073d9105a77a03c3f949858edd6d7727ce3f3d876"></a>TriangleArea&#160;</td><td class="fielddoc"><p>Divide cotangent weights by the area of the triangle. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00196">196</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="a32fd03ba183b8fb7890b0df54b9a4211" name="a32fd03ba183b8fb7890b0df54b9a4211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32fd03ba183b8fb7890b0df54b9a4211">&#9670;&#160;</a></span>ComputeNumMatrixElements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MeshT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> UE::MeshDeformation::ComputeNumMatrixElements </td>
          <td>(</td>
          <td class="paramtype">const MeshT &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>ToVtxId</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">20</a> of file <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html">PrecomputedMeshWeightData.h</a>.</p>

<p class="reference">References <a class="el" href="../../df/dd0/Array_8h_source.html#l01116">TArray&lt; InElementType, InAllocatorType &gt;::Num()</a>, and <a class="el" href="../../df/dd0/Array_8h_source.html#l02379">TArray&lt; InElementType, InAllocatorType &gt;::SetNumUninitialized()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00515">ConstructCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00616">ConstructCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00855">ConstructFullCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00983">ConstructFullIDTCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00712">ConstructIDTCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00443">ConstructMeanValueWeightLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00316">ConstructUmbrellaLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00265">ConstructUniformLaplacian()</a>, and <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00381">ConstructValenceWeightedLaplacian()</a>.</p>
<div id="dynsection-0" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 0 --></div>
</div>
<div id="dynsection-1" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 1 --></div>
</div>

</div>
</div>
<a id="a4812c7ce23c805e07abf7e769e99d6fe" name="a4812c7ce23c805e07abf7e769e99d6fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4812c7ce23c805e07abf7e769e99d6fe">&#9670;&#160;</a></span>ComputeSmoothing_BiHarmonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DYNAMICMESH_API UE::MeshDeformation::ComputeSmoothing_BiHarmonic </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a></td>          <td class="paramname"><span class="paramname"><em>WeightingScheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OriginalMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>Speed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>Weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>          <td class="paramname"><span class="paramname"><em>NumIterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PositionArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d99/classFProgressCancel.html">FProgressCancel</a> *</td>          <td class="paramname"><span class="paramname"><em>Progress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Note: for discussion of implicit / explicit integration of diffusion and biharmonic equations see "Implicit Fairing of Irregular Meshes using Diffusion and Curvature Flow" - M Desbrun 99. </p>
<p>although the following suggests an additional source term could be included in the implicit solve for better accuracy. or "Generalized Surface Flows for Mesh Processing" Eckstein et al. 2007 This is equivalent to taking a single backward Euler time step of bi-harmonic diffusion where L is the Laplacian (Del^2) , and L^T L is an approximation of the Del^4.</p>
<p>dp/dt = - k*k L^T L[p]</p>
<p>p^{n+1} + dt * k * k L^TL [p^{n+1}] = p^{n}</p>
<p>re-write as L^TL[p^{n+1}] + weight * weight p^{n+1} = weight * weight p^{n} with weight = 1 / (k * Sqrt[dt] )</p>
<p>The result is returned in the PositionArray Note: if canceled using the optional <a class="el" href="../../de/d99/classFProgressCancel.html" title="FProgressCancel is intended to be passed to long-running computes to do two things: 1) provide progre...">FProgressCancel</a>, the results may be in an unusable state. </p>

<p class="reference">References <a class="el" href="../../d5/d79/UnitConversion_8h_source.html#l00099">Speed</a>, and <a class="el" href="../../db/d95/MovieSceneSection_8h_source.html#l00232">Weight</a>.</p>

</div>
</div>
<a id="a2db09148a561437e685887afd3853ddc" name="a2db09148a561437e685887afd3853ddc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2db09148a561437e685887afd3853ddc">&#9670;&#160;</a></span>ComputeSmoothing_Diffusion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DYNAMICMESH_API UE::MeshDeformation::ComputeSmoothing_Diffusion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a></td>          <td class="paramname"><span class="paramname"><em>WeightScheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OriginalMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em>bForwardEuler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>Speed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>Weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>          <td class="paramname"><span class="paramname"><em>NumIterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PositionArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d99/classFProgressCancel.html">FProgressCancel</a> *</td>          <td class="paramname"><span class="paramname"><em>Progress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is equivalent to forward or backward Euler time steps of the diffusion equation. </p>
<p>dp/dt = L[p]</p>
<p>p^{n+1} = p^{n} + dt L[p^{n}]</p>
<p>with dt = Speed / Max(|w_ii|)</p>
<p>here w_ii are the diagonal values of L Note: if canceled using the optional <a class="el" href="../../de/d99/classFProgressCancel.html" title="FProgressCancel is intended to be passed to long-running computes to do two things: 1) provide progre...">FProgressCancel</a>, the results may be in an unusable state. </p>

<p class="reference">References <a class="el" href="../../d5/d79/UnitConversion_8h_source.html#l00099">Speed</a>, and <a class="el" href="../../db/d95/MovieSceneSection_8h_source.html#l00232">Weight</a>.</p>

</div>
</div>
<a id="afb592ec10a02935bf6842a81ae5f9799" name="afb592ec10a02935bf6842a81ae5f9799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb592ec10a02935bf6842a81ae5f9799">&#9670;&#160;</a></span>ComputeSmoothing_Forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DYNAMICMESH_API UE::MeshDeformation::ComputeSmoothing_Forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em>bUniformWeightScheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em>bSmoothBoundary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OriginalMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../de/d23/classTFunctionRef.html">TFunctionRef</a>&lt; double(int VID, <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a> bBoundary)&gt;</td>          <td class="paramname"><span class="paramname"><em>GetSmoothingAlpha</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>          <td class="paramname"><span class="paramname"><em>NumIterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PositionArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class <a class="el" href="../../de/d99/classFProgressCancel.html">FProgressCancel</a> *</td>          <td class="paramname"><span class="paramname"><em>Progress</em></span><span class="paramdefsep"> = </span><span class="paramdefval">nullptr</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple iterative smoothing with an optional weight map Each iteration Lerps towards the weighted neighbor centroid by the GetSmoothingAlpha amount. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bUniformWeightScheme</td><td>If true, uses uniform weights for centroid; else uses cotan weights </td></tr>
    <tr><td class="paramname">bSmoothBoundary</td><td>If true, boundary vertices are smoothed (toward the centroid of neighboring boundary vertices); else boundary is fixed </td></tr>
    <tr><td class="paramname">OriginalMesh</td><td>The source mesh, used for topology </td></tr>
    <tr><td class="paramname">GetSmoothingAlpha</td><td>The amount to lerp each vertex towards the centroid, per iteration </td></tr>
    <tr><td class="paramname">NumIterations</td><td>Number of iterations to smooth </td></tr>
    <tr><td class="paramname">PositionsArray</td><td>Vertex positions (input and output) </td></tr>
    <tr><td class="paramname">Progress</td><td>An optional interrupter that can terminate the iterations, leaving the results in an unusable state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac30f576ea7bf67c2a0f35b3596ddb055" name="ac30f576ea7bf67c2a0f35b3596ddb055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac30f576ea7bf67c2a0f35b3596ddb055">&#9670;&#160;</a></span>ComputeSmoothing_ImplicitBiHarmonicPCG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DYNAMICMESH_API UE::MeshDeformation::ComputeSmoothing_ImplicitBiHarmonicPCG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a></td>          <td class="paramname"><span class="paramname"><em>WeightScheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>OriginalMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>Speed</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>Weight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d">int32</a></td>          <td class="paramname"><span class="paramname"><em>MaxIterations</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>PositionArray</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="reference">References <a class="el" href="../../d5/d79/UnitConversion_8h_source.html#l00099">Speed</a>, and <a class="el" href="../../db/d95/MovieSceneSection_8h_source.html#l00232">Weight</a>.</p>

</div>
</div>
<a id="af7b567308bbbd1c53a64485d79191860" name="af7b567308bbbd1c53a64485d79191860"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b567308bbbd1c53a64485d79191860">&#9670;&#160;</a></span>ConstructConstrainedMeshDeformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../de/da0/classUE_1_1Solvers_1_1IConstrainedMeshSolver.html">UE::Solvers::IConstrainedMeshSolver</a> &gt; DYNAMICMESH_API UE::MeshDeformation::ConstructConstrainedMeshDeformer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a></td>          <td class="paramname"><span class="paramname"><em>WeightScheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the linear system for p_vec. </p>
<pre class="fragment">   ( Transpose(L) * L   + (0  0      )  ) p_vec = source_vec + ( 0              )
 (                      (0 lambda^2)  )                      ( lambda^2 c_vec )
</pre><p>where: L := laplacian for the mesh, source_vec := Transpose(L)*L mesh_vertex_positions lambda := weights c_vec := constrained positions</p>
<p>Expected Use:</p>
<p>// Create Deformation Solver from Mesh <a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr&lt;IConstrainedMeshSolver&gt;</a> MeshDeformer = ConstructConstrainedMeshDeformer(ELaplacianWeightScheme::ClampedCotangent, DynamicMesh);</p>
<p>// Add constraints. for.. { <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d" title="A 32-bit signed integer.">int32</a> VtxId = ..; double Weight = ..; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> TargetPos = ..; bool bPostFix = ...; MeshDeformer-&gt;AddConstraint(VtxId, Weight, TargetPos, bPostFix); }</p>
<p>// Solve for new mesh vertex locations <a class="el" href="../../d4/d52/classTArray.html" title="Templated dynamic array.">TArray&lt;FVector3d&gt;</a> PositionBuffer; MeshDeformer-&gt;Deform(PositionBuffer);</p>
<p>// Update Mesh? for (<a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d" title="A 32-bit signed integer.">int32</a> VtxId : DynamicMesh.VertexIndices()) DynamicMesh.SetVertex(VtxId, PositionBuffer[VtxId]); ...</p>
<p>// Update constraint positions. for .. { <a class="el" href="../../d9/dd0/Platform_8h.html#a8dbb3cd84ca9fd010dadfc3815eefa5d" title="A 32-bit signed integer.">int32</a> VtxId = ..; <a class="el" href="../../d2/d10/MathFwd_8h.html#a9692a317ebc5608791da932738c8d36b">FVector3d</a> TargetPos = ..; bool bPostFix = ...; MeshDeformer-&gt;UpdateConstraintPosition(VtxId, TargetPos, bPostFix); }</p>
<p>// Solve for new vertex locations. MeshDeformer-&gt;Deform(PositionBuffer); // Update Mesh? </p>

<p class="reference">Referenced by <a class="el" href="../../da/d6c/MeshOffsetOps_8h_source.html#l00327">UE::Geometry::FLaplacianOffsetMeshOp::Offset()</a>.</p>
<div id="dynsection-2" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-2-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-2-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 2 --></div>
</div>

</div>
</div>
<a id="a5cf07468a64a284a2edbd8dbc4139a36" name="a5cf07468a64a284a2edbd8dbc4139a36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cf07468a64a284a2edbd8dbc4139a36">&#9670;&#160;</a></span>ConstructConstrainedMeshSmoother()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../de/da0/classUE_1_1Solvers_1_1IConstrainedMeshSolver.html">UE::Solvers::IConstrainedMeshSolver</a> &gt; DYNAMICMESH_API UE::MeshDeformation::ConstructConstrainedMeshSmoother </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d22/MeshLaplacian_8h.html#ad130f2604e40ab5b31676817b00982cb">ELaplacianWeightScheme</a></td>          <td class="paramname"><span class="paramname"><em>WeightScheme</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the linear system for p_vec. </p>
<pre class="fragment">   ( Transpose(L) * L   + (0  0      )  ) p_vec = ( 0              )
 (                      (0 lambda^2)  )         ( lambda^2 c_vec )
</pre><p>where: L := laplacian for the mesh, lambda := weights c_vec := constrained positions</p>
<p>Expected Use: same as the ConstrainedMeshDeformer above. </p>

</div>
</div>
<a id="abb5ba9e1b374edf6d77271067c602718" name="abb5ba9e1b374edf6d77271067c602718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb5ba9e1b374edf6d77271067c602718">&#9670;&#160;</a></span>ConstructCotangentLaplacian() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructCotangentLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>AreaMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation using a cotangent-weighted Laplacian. </p>
<p>but returns the result in two symmetric parts.</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<p>(AreaMatrix^{-1}) * L_hat = Cotangent weighted Laplacian.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">AreaMatrix</td><td>On return, the mass matrix for the internal vertices. sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, the laplacian operator that acts on the interior vertices: sparse N x N matrix - symmetric </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, the portion of the operator that acts on the boundary vertices: sparse N x M matrix</td></tr>
  </table>
  </dd>
</dl>
<p>AreaMatrix^{-1} * ( LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts) = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00515">515</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../d0/dfa/AssertionMacros_8h_source.html#l00345">checkSlow</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00208">ConstructTriangleDataArray()</a>, <a class="el" href="../../d7/d9a/GeometrySelection_8h_source.html#l00119">UE::Geometry::Edge</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00760">UE::Geometry::FDynamicMesh3::GetEdge()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00091">UE::MeshDeformation::CotanTriangleData::GetOpposingCotangent()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00696">UE::Geometry::FDynamicMesh3::GetTriangle()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00153">UE::Geometry::FDynamicMesh3::InvalidID</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00134">UE::Geometry::FTriangleLinearization::NumTris()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00137">UE::MeshDeformation::CotanTriangleData::VoronoiArea</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00542">UE::Geometry::FDynamicMesh3::VtxEdgesItr()</a>, and <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00557">UE::Geometry::FDynamicMesh3::VtxTrianglesItr()</a>.</p>
<div id="dynsection-3" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-3-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-3-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 3 --></div>
</div>

</div>
</div>
<a id="aaf997123f9e9bc9c6853c6ba0330b986" name="aaf997123f9e9bc9c6853c6ba0330b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf997123f9e9bc9c6853c6ba0330b986">&#9670;&#160;</a></span>ConstructCotangentLaplacian() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructCotangentLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em>bClampWeights</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation using a pre-multiplied cotangent-weighted Laplacian. </p>
<p>NB: there is no reason to expect this to be a symmetric matrix.</p>
<p>This computes the laplacian scaled by the average area A_ave: ie. LScaled = A_ave/(2A_i) ( Cot alpha_ij + Cot beta_ij )</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, scaled laplacian operator that acts on the interior vertices: sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, scaled portion of the operator that acts on the boundary vertices: sparse N x M matrix </td></tr>
    <tr><td class="paramname">bClampAreas</td><td>Indicates if (A_ave / A_i) should be clamped to (0.5, 5) range. in practice this is desirable when creating the biharmonic operator, but not the mean curvature flow operator</td></tr>
  </table>
  </dd>
</dl>
<p>LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00616">616</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../d0/dfa/AssertionMacros_8h_source.html#l00345">checkSlow</a>, <a class="el" href="../../df/d8b/classTMathUtil.html#a5140b8f6ca300865afb4f248051d5b08">TMathUtil&lt; double &gt;::Clamp()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00208">ConstructTriangleDataArray()</a>, <a class="el" href="../../d7/d9a/GeometrySelection_8h_source.html#l00119">UE::Geometry::Edge</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00760">UE::Geometry::FDynamicMesh3::GetEdge()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00091">UE::MeshDeformation::CotanTriangleData::GetOpposingCotangent()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00696">UE::Geometry::FDynamicMesh3::GetTriangle()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00153">UE::Geometry::FDynamicMesh3::InvalidID</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00134">UE::Geometry::FTriangleLinearization::NumTris()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00137">UE::MeshDeformation::CotanTriangleData::VoronoiArea</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00542">UE::Geometry::FDynamicMesh3::VtxEdgesItr()</a>, and <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00557">UE::Geometry::FDynamicMesh3::VtxTrianglesItr()</a>.</p>
<div id="dynsection-4" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-4-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-4-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 4 --></div>
</div>

</div>
</div>
<a id="aa5a170f0f1f1086b297d466bfe1f8ca1" name="aa5a170f0f1f1086b297d466bfe1f8ca1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5a170f0f1f1086b297d466bfe1f8ca1">&#9670;&#160;</a></span>ConstructEdgeCotanWeightsDataArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DYNAMICMESH_API UE::MeshDeformation::ConstructEdgeCotanWeightsDataArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; double &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>EdgeWeightsDataArray</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ClampMin</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1.e5</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>ClampMax</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1.e5</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Edge cotanget weights. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="../../dd/da0/todo.html#_todo000004">Todo</a></b></dt><dd>Add an option to return the weights computed on an intrinsic mesh. </dd></dl>

<p class="reference">References <a class="el" href="../../d2/da0/GeometrySelectionUtil_8h_source.html#l00112">UE::Geometry::Mesh</a>.</p>

</div>
</div>
<a id="ae792924418f806431fc29afa28c3716f" name="ae792924418f806431fc29afa28c3716f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae792924418f806431fc29afa28c3716f">&#9670;&#160;</a></span>ConstructFullCotangentLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructFullCotangentLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a445122076708a599dcff3ea2073d9105">ECotangentWeightMode</a></td>          <td class="paramname"><span class="paramname"><em>WeightMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb">ECotangentWeightMode::ClampedMagnitude</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490f">ECotangentAreaMode</a></td>          <td class="paramname"><span class="paramname"><em>AreaMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55">ECotangentAreaMode::NoArea</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct sparse Cotangent Laplacian matrix. </p>
<p>This variant combines the N interior and M boundary vertices into a single (N+M) matrix and does not do any special treatment of boundaries, they just get standard Cotan weights</p>
<p>If you don't want to move the boundary vertices to the end, then initialize the VertexMap with bRemapBoundary set to false.</p>
<p>Example usage:</p>
<p>If you want to get the standard cotangent weight matrix for a mesh with no boundary reordering:</p>
<p><a class="el" href="../../d9/df6/classFDynamicMesh3.html" title="FDynamicMesh3 is a dynamic triangle mesh class.">FDynamicMesh3</a> DynamicMesh; const bool bRemapBoundary = false; <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html" title="Used to linearize the VtxIds in a mesh as a single array and allow mapping from array offset to mesh ...">FVertexLinearization</a> VertexMap(DynamicMesh, bRemapBoundary); ConstructFullCotangentLaplacian(DynamicMesh, VertexMap, ECotangentWeightMode::Default, ECotangentAreaMode::NoArea); </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00855">855</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../df/dd0/Array_8h_source.html#l02706">TArray&lt; InElementType, InAllocatorType &gt;::Add()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00042">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntriesFunc</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00141">UE::MeshDeformation::CotanTriangleData::Area</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00592">FMath::Clamp()</a>, <a class="el" href="../../df/d8b/classTMathUtil.html#a5140b8f6ca300865afb4f248051d5b08">TMathUtil&lt; double &gt;::Clamp()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00201">ClampedMagnitude</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00208">ConstructTriangleDataArray()</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00722">FMath::DivideAndRoundUp()</a>, <a class="el" href="../../d7/d9a/GeometrySelection_8h_source.html#l00119">UE::Geometry::Edge</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l02571">TArray&lt; InElementType, InAllocatorType &gt;::Emplace()</a>, <a class="el" href="../../d2/d70/IndexUtil_8h_source.html#l00061">IndexUtil::FindTriIndex()</a>, <a class="el" href="../../df/d19/classFTaskGraphInterface.html#abfd26b251bea43c5077b6b7adcc459be">FTaskGraphInterface::Get()</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l00999">TArray&lt; InElementType, InAllocatorType &gt;::GetData()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00091">UE::MeshDeformation::CotanTriangleData::GetOpposingCotangent()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00153">UE::Geometry::FDynamicMesh3::InvalidID</a>, <a class="el" href="../../db/d0e/Tasks_2Task_8h_source.html#l00299">UE::Tasks::Launch()</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00657">FMath::Max</a>, <a class="el" href="../../d2/da0/GeometrySelectionUtil_8h_source.html#l00112">UE::Geometry::Mesh</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00656">FMath::Min</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l01116">TArray&lt; InElementType, InAllocatorType &gt;::Num()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00134">UE::Geometry::FTriangleLinearization::NumTris()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l03026">TArray&lt; InElementType, InAllocatorType &gt;::Reserve()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l02320">TArray&lt; InElementType, InAllocatorType &gt;::SetNum()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00203">TriangleArea</a>, <a class="el" href="../../db/ddb/PreprocessorHelpers_8h_source.html#l00071">UE_SOURCE_LOCATION</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00137">UE::MeshDeformation::CotanTriangleData::VoronoiArea</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00212">VoronoiArea</a>, and <a class="el" href="../../db/d0e/Tasks_2Task_8h_source.html#l00440">UE::Tasks::Wait()</a>.</p>
<div id="dynsection-5" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-5-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-5-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 5 --></div>
</div>

</div>
</div>
<a id="a65dc6e343bd575c6673bf8c0b482ffde" name="a65dc6e343bd575c6673bf8c0b482ffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65dc6e343bd575c6673bf8c0b482ffde">&#9670;&#160;</a></span>ConstructFullIDTCotangentLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructFullIDTCotangentLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianMatrix</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a445122076708a599dcff3ea2073d9105">ECotangentWeightMode</a></td>          <td class="paramname"><span class="paramname"><em>WeightMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a445122076708a599dcff3ea2073d9105a598deb4a3375237d607118c8e4285cdb">ECotangentWeightMode::ClampedMagnitude</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490f">ECotangentAreaMode</a></td>          <td class="paramname"><span class="paramname"><em>AreaMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a9a874fe9f39817ee5f88f3791f4f490fa6415cf0aa957e880e566e459c58b7e55">ECotangentAreaMode::NoArea</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use intrinsic Delaunay mesh to construct sparse Cotangent Laplacian matrix. </p>
<p>This variant combines the N interior and M boundary vertices into a single (N+M) matrix and does not do any special treatment of boundaries, they just get standard Cotan weights. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00983">983</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d67/IndexTypes_8h_source.html#l00032">UE::Geometry::FIndex2i::A</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l01671">TArray&lt; InElementType, InAllocatorType &gt;::AddUninitialized()</a>, <a class="el" href="../../d5/d67/IndexTypes_8h_source.html#l00032">UE::Geometry::FIndex2i::B</a>, <a class="el" href="../../df/d8b/classTMathUtil.html#a5140b8f6ca300865afb4f248051d5b08">TMathUtil&lt; double &gt;::Clamp()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00201">ClampedMagnitude</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d4/d45/Set_8h_source.html#l00964">TSet&lt; InElementType, KeyFuncs, Allocator &gt;::Contains()</a>, <a class="el" href="../../db/d76/classUE_1_1Geometry_1_1FSimpleIntrinsicEdgeFlipMesh.html#a09522354406072be81788dc57bce63bf">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::EdgeCotanWeight()</a>, <a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#afceb5c153823240df0d8db0e8e15bd13">UE::Geometry::FlipToDelaunay()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00106">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::GetEdgeLength()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00217">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::GetEdgeV()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00197">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::IsEdge()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00191">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::MaxEdgeID()</a>, <a class="el" href="../../d2/da0/GeometrySelectionUtil_8h_source.html#l00112">UE::Geometry::Mesh</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00212">VoronoiArea</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00166">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::VtxEdgesItr()</a>, and <a class="el" href="../../db/d95/MovieSceneSection_8h_source.html#l00232">Weight</a>.</p>
<div id="dynsection-6" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-6-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-6-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 6 --></div>
</div>

</div>
</div>
<a id="ad7e9fddf45aa4a169e3cec1788bd8eee" name="ad7e9fddf45aa4a169e3cec1788bd8eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7e9fddf45aa4a169e3cec1788bd8eee">&#9670;&#160;</a></span>ConstructIDTCotangentLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructIDTCotangentLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em>bClampWeights</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation using a pre-multiplied cotangent-weighted Laplacian, using an intrinsic Delaunay mesh internally NB: there is no reason to expect this to be a symmetric matrix. </p>
<p>This computes the laplacian scaled by the average area A_ave: ie. LScaled = A_ave/(2A_i) ( Cot alpha_ij + Cot beta_ij )</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, scaled laplacian operator that acts on the interior vertices: sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, scaled portion of the operator that acts on the boundary vertices: sparse N x M matrix </td></tr>
    <tr><td class="paramname">bClampAreas</td><td>Indicates if (A_ave / A_i) should be clamped to (0.5, 5) range. in practice this is desirable when creating the biharmonic operator, but not the mean curvature flow operator</td></tr>
  </table>
  </dd>
</dl>
<p>LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00712">712</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d5/d67/IndexTypes_8h_source.html#l00032">UE::Geometry::FIndex2i::A</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l02765">TArray&lt; InElementType, InAllocatorType &gt;::AddZeroed()</a>, <a class="el" href="../../d5/d67/IndexTypes_8h_source.html#l00032">UE::Geometry::FIndex2i::B</a>, <a class="el" href="../../df/d8b/classTMathUtil.html#a5140b8f6ca300865afb4f248051d5b08">TMathUtil&lt; double &gt;::Clamp()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d4/d45/Set_8h_source.html#l00964">TSet&lt; InElementType, KeyFuncs, Allocator &gt;::Contains()</a>, <a class="el" href="../../db/d76/classUE_1_1Geometry_1_1FSimpleIntrinsicEdgeFlipMesh.html#a09522354406072be81788dc57bce63bf">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::EdgeCotanWeight()</a>, <a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#afceb5c153823240df0d8db0e8e15bd13">UE::Geometry::FlipToDelaunay()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00106">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::GetEdgeLength()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00217">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::GetEdgeV()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00197">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::IsEdge()</a>, <a class="el" href="../../df/d8b/classTMathUtil.html#a86aea4032b8128254507117600b4a3af">TMathUtil&lt; double &gt;::Max()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00191">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::MaxEdgeID()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, <a class="el" href="../../d7/d38/IntrinsicTriangulationMesh_8h_source.html#l00166">UE::Geometry::FSimpleIntrinsicEdgeFlipMesh::VtxEdgesItr()</a>, and <a class="el" href="../../db/d95/MovieSceneSection_8h_source.html#l00232">Weight</a>.</p>
<div id="dynsection-7" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-7-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-7-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 7 --></div>
</div>

</div>
</div>
<a id="a8cfb166d2dee288b2c69e7a3942f1f16" name="a8cfb166d2dee288b2c69e7a3942f1f16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cfb166d2dee288b2c69e7a3942f1f16">&#9670;&#160;</a></span>ConstructMeanValueWeightLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructMeanValueWeightLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation using a meanvalue-weighted Laplacian. </p>
<p>NB: there is no reason to expect this to be a symmetric matrix.</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, the laplacian operator that acts on the interior vertices: sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, the portion of the operator that acts on the boundary vertices: sparse N x M matrix</td></tr>
  </table>
  </dd>
</dl>
<p>LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00443">443</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00208">ConstructTriangleDataArray()</a>, <a class="el" href="../../d7/d9a/GeometrySelection_8h_source.html#l00119">UE::Geometry::Edge</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00760">UE::Geometry::FDynamicMesh3::GetEdge()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00153">UE::Geometry::FDynamicMesh3::InvalidID</a>, <a class="el" href="../../df/d8b/classTMathUtil.html#a86aea4032b8128254507117600b4a3af">TMathUtil&lt; double &gt;::Max()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00134">UE::Geometry::FTriangleLinearization::NumTris()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, and <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00542">UE::Geometry::FDynamicMesh3::VtxEdgesItr()</a>.</p>
<div id="dynsection-8" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-8-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-8-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 8 --></div>
</div>

</div>
</div>
<a id="aba3b027c57ad1b96ce0040240913f154" name="aba3b027c57ad1b96ce0040240913f154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba3b027c57ad1b96ce0040240913f154">&#9670;&#160;</a></span>ConstructNaturalConformalParamSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../d9/deb/classUE_1_1Solvers_1_1IConstrainedMeshUVSolver.html">UE::Solvers::IConstrainedMeshUVSolver</a> &gt; DYNAMICMESH_API UE::MeshDeformation::ConstructNaturalConformalParamSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create solver for the Least Squares Conformal UV Parameterization for this mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumption is that mesh is a single connected component. </dd></dl>

</div>
</div>
<a id="a5811e816dcc6ade5f779f52079d1527d" name="a5811e816dcc6ade5f779f52079d1527d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5811e816dcc6ade5f779f52079d1527d">&#9670;&#160;</a></span>ConstructSoftMeshDeformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../df/d0b/classUE_1_1Solvers_1_1IConstrainedLaplacianMeshSolver.html">UE::Solvers::IConstrainedLaplacianMeshSolver</a> &gt; DYNAMICMESH_API UE::MeshDeformation::ConstructSoftMeshDeformer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a Mesh Deformer object for the given mesh that uses Biharmonic Laplacian Mesh Deformation to solve for the deformed vertex positions. </p>
<p>Similar to <a class="el" href="#af7b567308bbbd1c53a64485d79191860" title="Solves the linear system for p_vec.">ConstructConstrainedMeshDeformer()</a> however (1) a Voronoi-Area Weighted Clamped Cotangent Laplacian is always used and (2) the boundary positions are included in the system. This allows for the solution of deformation problems where the boundary also moves, however it also means that constraints should be added for all boundary vertices or the deformation may be unstable. </p>

</div>
</div>
<a id="ab015c49845a42ccdf25b6f208a562e57" name="ab015c49845a42ccdf25b6f208a562e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab015c49845a42ccdf25b6f208a562e57">&#9670;&#160;</a></span>ConstructSpectralConformalParamSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../d9/deb/classUE_1_1Solvers_1_1IConstrainedMeshUVSolver.html">UE::Solvers::IConstrainedMeshUVSolver</a> &gt; DYNAMICMESH_API UE::MeshDeformation::ConstructSpectralConformalParamSolver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../da/d1e/RigVMController_8h.html#addff56abe65381e12af5473dd0c468ea">bool</a></td>          <td class="paramname"><span class="paramname"><em>bPreserveIrregularity</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create solver for the Spectral Conformal UV Parameterization for this mesh. </p>
<dl class="section warning"><dt>Warning</dt><dd>Assumption is that mesh is a single connected component. </dd></dl>

</div>
</div>
<a id="ad8780349428dfee6b9e4c2b338ee5ffc" name="ad8780349428dfee6b9e4c2b338ee5ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8780349428dfee6b9e4c2b338ee5ffc">&#9670;&#160;</a></span>ConstructTriangleDataArray()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TriangleDataType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructTriangleDataArray </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/dc2/classUE_1_1Geometry_1_1FTriangleLinearization.html">FTriangleLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>TriangleLinearization</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d52/classTArray.html">TArray</a>&lt; TriangleDataType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>TriangleDataArray</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return and array in triangle order that holds the per-triangle derived data needed. </p>

<p class="definition">Definition at line <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00208">208</a> of file <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html">PrecomputedMeshWeightData.h</a>.</p>

<p class="reference">References <a class="el" href="../../df/dd0/Array_8h_source.html#l02706">TArray&lt; InElementType, InAllocatorType &gt;::Add()</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00722">FMath::DivideAndRoundUp()</a>, <a class="el" href="../../df/d19/classFTaskGraphInterface.html#abfd26b251bea43c5077b6b7adcc459be">FTaskGraphInterface::Get()</a>, <a class="el" href="../../db/d0e/Tasks_2Task_8h_source.html#l00299">UE::Tasks::Launch()</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00657">FMath::Max</a>, <a class="el" href="../../db/db8/UnrealMathUtility_8h_source.html#l00656">FMath::Min</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00134">UE::Geometry::FTriangleLinearization::NumTris()</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l03026">TArray&lt; InElementType, InAllocatorType &gt;::Reserve()</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l02379">TArray&lt; InElementType, InAllocatorType &gt;::SetNumUninitialized()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../db/ddb/PreprocessorHelpers_8h_source.html#l00071">UE_SOURCE_LOCATION</a>, and <a class="el" href="../../db/d0e/Tasks_2Task_8h_source.html#l00440">UE::Tasks::Wait()</a>.</p>

<p class="reference">Referenced by <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00515">ConstructCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00616">ConstructCotangentLaplacian()</a>, <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00855">ConstructFullCotangentLaplacian()</a>, and <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00443">ConstructMeanValueWeightLaplacian()</a>.</p>
<div id="dynsection-9" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-9-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-9-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 9 --></div>
</div>
<div id="dynsection-10" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the caller graph for this function:</div>
<div id="dynsection-10-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-10-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 10 --></div>
</div>

</div>
</div>
<a id="a1e94c672286fff67d41a1398142f4827" name="a1e94c672286fff67d41a1398142f4827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e94c672286fff67d41a1398142f4827">&#9670;&#160;</a></span>ConstructUmbrellaLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructUmbrellaLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation of an umbrella weighted Laplacian. </p>
<p>This Laplacian is defined solely in terms of the connectivity of the mesh. Note, there is no expectation that the resulting matrix will be symmetric.</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<p>Row i represents the Laplacian at vert_i, the non-zero entries correspond to the incident one-ring vertices vert_j.</p>
<p>L_{ij} = 1 / valence(of i) if vert_j is in the one-ring of vert_i L_{ii} = -Sum{ L_{ij}, j != i} = -1</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, the laplacian operator that acts on the interior vertices: sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, the portion of the operator that acts on the boundary vertices: sparse N x M matrix</td></tr>
  </table>
  </dd>
</dl>
<p>LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00316">316</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../d0/dfa/AssertionMacros_8h_source.html#l00345">checkSlow</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00687">UE::Geometry::FDynamicMesh3::GetVtxEdgeCount()</a>, <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html#a563fc25f8181c49936b47524450f7535">UE::Geometry::FDynamicMesh3::IsBoundaryVertex()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l02379">TArray&lt; InElementType, InAllocatorType &gt;::SetNumUninitialized()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, <a class="el" href="../../d2/d22/MeshLaplacian_8h_source.html#l00020">Valence</a>, and <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00523">UE::Geometry::FDynamicMesh3::VtxVerticesItr()</a>.</p>
<div id="dynsection-11" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-11-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-11-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 11 --></div>
</div>

</div>
</div>
<a id="a16f5e009a2ea06db28ac0ba7bd34d87a" name="a16f5e009a2ea06db28ac0ba7bd34d87a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f5e009a2ea06db28ac0ba7bd34d87a">&#9670;&#160;</a></span>ConstructUniformConstrainedMeshDeformer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d9/df6/classTUniquePtr.html">TUniquePtr</a>&lt; <a class="el" href="../../de/da0/classUE_1_1Solvers_1_1IConstrainedMeshSolver.html">UE::Solvers::IConstrainedMeshSolver</a> &gt; DYNAMICMESH_API UE::MeshDeformation::ConstructUniformConstrainedMeshDeformer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d9/d39/namespaceUE_1_1Geometry.html#aeb80441b3597cadec9dd41631706afe3">FDynamicGraph3d</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>Graph</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interface for a mesh with only edges and vertices. </p>
<p>Construct a Mesh Deformer object for the given generic mesh that uses Biharmonic Laplacian Mesh Deformation to solve for the deformed vertex positions.</p>
<p>Similar to <a class="el" href="#af7b567308bbbd1c53a64485d79191860" title="Solves the linear system for p_vec.">ConstructConstrainedMeshDeformer()</a> however a uniform-weighted Laplacian is always used. This allows for the solution of deformation problems on a more generic mesh type (triangles or faces are not required.) </p>

</div>
</div>
<a id="a694b1bb9f614a1046908e13b7315c5f7" name="a694b1bb9f614a1046908e13b7315c5f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a694b1bb9f614a1046908e13b7315c5f7">&#9670;&#160;</a></span>ConstructUniformLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType, typename MeshType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructUniformLaplacian </td>
          <td>(</td>
          <td class="paramtype">const MeshType &amp;</td>          <td class="paramname"><span class="paramname"><em>Mesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation of a uniform weighted Laplacian. </p>
<p>The uniform weighted Laplacian is defined solely in terms of the connectivity of the mesh. Note, by construction this should be a symmetric matrix.</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<p>Row i represents the Laplacian at vert_i, the non-zero entries correspond to the incident one-ring vertices vert_j.</p>
<p>L_{ij} = 1 if vert_j is in the one-ring of vert_i L_{ii} = -Sum{ L_{ij}, j != i}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>On return, Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, the laplacian operator that acts on the interior vertices: sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, the portion of the operator that acts on the boundary vertices: sparse N x M matrix</td></tr>
  </table>
  </dd>
</dl>
<p>LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00265">265</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../d0/dfa/AssertionMacros_8h_source.html#l00345">checkSlow</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d2/da0/GeometrySelectionUtil_8h_source.html#l00112">UE::Geometry::Mesh</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, and <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>.</p>
<div id="dynsection-12" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-12-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-12-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 12 --></div>
</div>

</div>
</div>
<a id="a7f0420ccd091c996034cc49e0c4c8ee2" name="a7f0420ccd091c996034cc49e0c4c8ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0420ccd091c996034cc49e0c4c8ee2">&#9670;&#160;</a></span>ConstructValenceWeightedLaplacian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RealType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void UE::MeshDeformation::ConstructValenceWeightedLaplacian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d27/classUE_1_1Geometry_1_1FDynamicMesh3.html">FDynamicMesh3</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>DynamicMesh</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/df4/classUE_1_1Geometry_1_1FVertexLinearization.html">FVertexLinearization</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>VertexMap</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianInterior</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/ddf/classUE_1_1Solvers_1_1TSparseMatrixAssembler.html">UE::Solvers::TSparseMatrixAssembler</a>&lt; RealType &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>LaplacianBoundary</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a sparse matrix representation of a valence-weighted Laplacian. </p>
<p>The valence weighted Laplacian is defined solely in terms of the connectivity of the mesh. Note, by construction this should be a symmetric matrix.</p>
<p>The mesh itself is assumed to have N interior vertices, and M boundary vertices.</p>
<p>Row i represents the Laplacian at vert_i, the non-zero entries correspond to the incident one-ring vertices vert_j.</p>
<p>L_{ij} = 1/\sqrt(valence(i) + valence(j)) if vert_j is in the one-ring of vert_i L_{ii} = -Sum{ L_{ij}, j != i}</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">DynamicMesh</td><td>The triangle mesh </td></tr>
    <tr><td class="paramname">VertexMap</td><td>Additional arrays used to map between vertexID and offset in a linear array (i.e. the row). The vertices are ordered so that last M ( = VertexMap.NumBoundaryVerts() ) correspond to those on the boundary. </td></tr>
    <tr><td class="paramname">LaplacianInterior</td><td>On return, the laplacian operator that acts on the interior vertices: sparse N x N matrix </td></tr>
    <tr><td class="paramname">LaplacianBoundary</td><td>On return, the portion of the operator that acts on the boundary vertices: sparse N x M matrix</td></tr>
  </table>
  </dd>
</dl>
<p>LaplacianInterior * Vector_InteriorVerts + LaplacianBoundary * Vector_BoundaryVerts = Full Laplacian applied to interior vertices. </p>

<p class="definition">Definition at line <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html#l00381">381</a> of file <a class="el" href="../../d4/dff/LaplacianMatrixAssembly_8h_source.html">LaplacianMatrixAssembly.h</a>.</p>

<p class="reference">References <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00027">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::AddEntryFunc</a>, <a class="el" href="../../d7/def/PrecomputedMeshWeightData_8h_source.html#l00020">ComputeNumMatrixElements()</a>, <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00687">UE::Geometry::FDynamicMesh3::GetVtxEdgeCount()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00052">UE::Geometry::FVertexLinearization::NumBoundaryVerts()</a>, <a class="el" href="../../d5/da8/MeshLinearization_8h_source.html#l00050">UE::Geometry::FVertexLinearization::NumVerts()</a>, <a class="el" href="../../d3/da8/MatrixInterfaces_8h_source.html#l00024">UE::Solvers::TSparseMatrixAssembler&lt; RealType &gt;::ReserveEntriesFunc</a>, <a class="el" href="../../df/dd0/Array_8h_source.html#l02379">TArray&lt; InElementType, InAllocatorType &gt;::SetNumUninitialized()</a>, <a class="el" href="../../d4/d5b/MathUtil_8h_source.html#l00342">TMathUtil&lt; RealType &gt;::Sqrt()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00027">UE::Geometry::FElementLinearization::ToId()</a>, <a class="el" href="../../d7/d90/ElementLinearization_8h_source.html#l00030">UE::Geometry::FElementLinearization::ToIndex()</a>, and <a class="el" href="../../d5/d34/DynamicMesh3_8h_source.html#l00523">UE::Geometry::FDynamicMesh3::VtxVerticesItr()</a>.</p>
<div id="dynsection-13" onclick="return dynsection.toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;"><span class="dynarrow"><span class="arrowhead closed"></span></span>Here is the call graph for this function:</div>
<div id="dynsection-13-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-13-content" class="dyncontent" style="display:none;">
<div class="center"><!-- SVG 13 --></div>
</div>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="../../da/d75/namespaceUE.html">UE</a></li><li class="navelem"><a href="../../da/df1/namespaceUE_1_1MeshDeformation.html">MeshDeformation</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for Unreal Engine 5.6 C++ API by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
